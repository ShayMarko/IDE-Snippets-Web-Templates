<templateSet group="user">
  <template name="sm::general::textToAsciiConverter" value="import java.awt.*;&#10;import java.awt.image.BufferedImage;&#10;&#10;public class Converter {&#10;&#10;    private static final int WIDTH = 100;&#10;    private static final int HEIGHT = 30;&#10;    private static final String SIGN = &quot;*&quot;;&#10;    private static final String FONT = &quot;Arial&quot;;&#10;&#10;    public static void converter(String toConvert, boolean lowerCase) {&#10;        toConvert = lowerCase ? toConvert.toLowerCase() : toConvert.toUpperCase();&#10;        BufferedImage image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);&#10;        Graphics g = image.getGraphics();&#10;        g.setFont(new Font(FONT, Font.BOLD, 24));&#10;&#10;        Graphics2D graphics = (Graphics2D) g;&#10;        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;        graphics.drawString(toConvert, 10, 20);&#10;&#10;        for (int y = 0; y &lt; HEIGHT; y++) {&#10;            StringBuilder sb = new StringBuilder();&#10;            for (int x = 0; x &lt; WIDTH; x++) {&#10;                sb.append(image.getRGB(x, y) == -16777216 ? &quot; &quot; : SIGN);&#10;            }&#10;            if (sb.toString().trim().isEmpty()) {&#10;                continue;&#10;            }&#10;            System.out.println(sb);&#10;         }&#10;    }&#10;&#10;    public static void getAllFonts() {&#10;        GraphicsEnvironment graphics = GraphicsEnvironment.getLocalGraphicsEnvironment();&#10;        Font[] fonts = graphics.getAllFonts();&#10;        for (int i = 0; i &lt; fonts.length; i++) {&#10;            System.out.print(fonts[i].getFontName() + &quot; : &quot;);&#10;            System.out.println(fonts[i].getFamily());&#10;        }&#10;    }&#10;&#10;}&#10;" description="Converts a String to Ascii Art based text" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::simpleSingleton" value="/*&#10; * When a few objects have the same values. &#10;   Instead of creating them a few times, and *each one of them have his object reference to the heap* (Memory leak!  out of memory exception),&#10;   we can make 1 object with the &quot;duplicated&quot; values and each semi-object will get the same heap-adress to him.&#10;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  &#10;  * ------------&#10;    | 4 steps: |&#10;    ------------&#10;         1. Make the &quot;main&quot; object in the class. this object will be *private static*&#10;            Others can reach to him but only from the class object (--&gt;From the getter [whom set to public])&#10;         2. Set the Constructor to private so no one could make another instance of the object&#10;         3. Generate *ONLY* getter - In order to reach to the object&#10;         4. Use multi-lock pattern when working with thread's:&#10;            When a program contains multi thread's and we want to have only 1 instance, we would have to use &quot;multi lock pattern&quot; in getInstance() method.&#10;            Multi lock is, a smart way to prevent from multi-thread program accidentally make more then one instance on the one hand,&#10;            and on the other hand - keep the program's performance as good as posible.&#10;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  &#10;  * Multi-lock: First condition: We want to reduce performance problems as posible,&#10;                                 So in order to do that - we would like to enter 'Synchronized' block only when instance is null&#10;                                 (-&gt; Instance have not been instanciated yet) and not each time getInstance() is invoked, otherwise - just return the instance.&#10;    Sychronized block: Using this block allows only to 1 thread continue each time. When 1 is already inside, other threads will wait. &#10;    Second condition:  When program have more then 1 thread, There could be a situation where 2 (or more) threads would enter the getInstance method at the same time and instance didn't instanciated yet.&#10;                       In this case, we would use the 'Syncronized' block in order to let only 1 thread continue and instanciate the instance.&#10;                       The problem is, when the first thread will finish and exit the block and since both threads already passed the null condition, &#10;                       the second thread will get in and instanciate another instance. &#10;                       To prevent that - We will make another condition after the 'Synchronized' block  in order to check if instance have been instanciated while second thread waited.&#10;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------      &#10;  * ------------&#10;    |  Notes:  |&#10;    ------------&#10;         1. You can make as much as free methods u want.&#10;         2. You can change the object values with the class setters (If you choose to make some.)&#10;            Changing it will change for all semi-object of course(because they have the same object reference adress in the heap)&#10;         3. Also, read here: https://www.ibm.com/developerworks/java/library/j-dcl/index.html&#10;&#10; */&#10;&#10;public class Singelton {&#10;&#10;    private static ClassName instance;&#10;&#10;    private ClassName(param1, param2, param3) {&#10;&#10;    }&#10;&#10;    public static 'ClassName' getInstance() {&#10;        if (instance == null) {&#10;            synchronized (ClassName.class) {&#10;                if (instance == null) {&#10;                    instance = new instance();&#10;                }&#10;            }&#10;        }&#10;        return instance;&#10;    }&#10;&#10;}&#10;" description="Simple singleton" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::enumSingelton" value="public enum explainSingelton {&#10;// The name of the singelton enum class should the same as the name of the class you want to make singelton instance from (just include 'My' in the start of the name)&#10;&#10;    INSTANCE;&#10;// Creating 1 instance(live object) called 'INSTANCE'&#10;// This could also contain parameters. Ex: Company(&quot;Name&quot;); -&gt; Every param that we would like the INSTANCE to have should be instelaized in this class private ctr OR in the targetClass CTR&#10;&#10;    private TargetClassName targetClassName;&#10;// Creating an object called &quot;targetClassName&quot; which refers to TargetClassName class&#10;&#10;    public TargetClassName getInstance() {&#10;        return targetClassName;&#10;    }&#10;&#10;    private private explainSingelton() { // Private ctr&#10;        this.targetClassName = Adress // Adress should be link to the TargetClassName.Ctr which there we define all properties we want the single instance will have(like name)&#10;    }&#10;&#10;}&#10;&#10;class anyClass { // Example of other classes in the project&#10;&#10;    private void b() { // We should call the instance only from a functions(Best practice!)&#10;        explainSingelton.INSTANCE.getInstance(); // Example of how to invoke the singelton instance of TargetClassName&#10;    }&#10;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::beanController" value="&#10;@RestController&#10;@RequestMapping(&quot;X&quot;)&#10;@RequiredArgsConstructor&#10;public class CatController {&#10;&#10;    /* HttpStatus per HttpRequest:&#10;     * POST - ''OK'(200), 'Accepted'(202), 'Created'(201)&#10;     * PUT - 'OK'(200), 'Accepted'(202), 'No Content'(204)&#10;     * GET - 'OK'(200)&#10;     * DELETE - 'OK'(200), 'Accepted'(202), 'No Content'(204)&#10;     */&#10;&#10;    private final Service service;&#10;    private final Repo repo;&#10;&#10;    @PostMapping(&quot;add&quot;) // http://localhost:8080/X/add&#10;    @ResponseStatus(value = HttpStatus.CREATED)&#10;    public void add(@RequestBody Bean bean) {&#10;        service.add(bean);&#10;    }&#10;&#10;    @PutMapping(&quot;update&quot;) // http://localhost:8080/X/update&#10;    @ResponseStatus(value = HttpStatus.NO_CONTENT)&#10;    public void updateBean(@RequestBody Bean bean) throws BeanException {&#10;        service.update(bean);&#10;    }&#10;&#10;    @GetMapping(&quot;getSingle/{id}&quot;) // http://localhost:8080/X/getSingle&#10;    public ResponseEntity&lt;List&lt;Bean&gt;&gt; getSingle(@PathVariable int id) {&#10;        return new ResponseEntity&lt;&gt;(service.getSingle(id), HttpStatus.OK);&#10;    }&#10;&#10;    /*&#10;    @GetMapping(&quot;getAll&quot;) // http://localhost:8080/X/getAll&#10;    @ResponseStatus(value = HttpStatus.OK)&#10;    public ResponseEntity&lt;List&lt;Bean&gt;&gt; getAllBean() { &#10;        return new ResponseEntity&lt;&gt;(service.getAll(), HttpStatus.OK);&#10;    }&#10;     */&#10;&#10;    @GetMapping(&quot;getAll&quot;) // http://localhost:8080/X/getAll&#10;    public ResponseEntity&lt;?&gt; getAllBean() {&#10;        return new ResponseEntity&lt;&gt;(new BeanList(service.getAll()), HttpStatus.OK);&#10;    }&#10;&#10;    @DeleteMapping(&quot;deleteById/{id}&quot;) // http://localhost:8080/X/deleteById/id&#10;    @ResponseStatus(value = HttpStatus.NO_CONTENT)&#10;    public void deleteBeanById(@PathVariable int id) throws BeanException {&#10;        service.delete(repo.getById(id));&#10;    }&#10;&#10;    @GetMapping(&quot;getAll/name/weight&quot;) // http://localhost:8080/X/getAllByNameAndWeight?name=Litzi&amp;weight=3.1&#10;    public ResponseEntity&lt;List&lt;Bean&gt;&gt; getAllByNameAndWeight(@RequestParam String name, @RequestParam float weight) throws BeanException {&#10;        return new ResponseEntity&lt;&gt;(service.getAllByNameAndWeight(name, weight), HttpStatus.OK);&#10;    }&#10;&#10;}" description="Controller prototype with every http request" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::appProperties" value="spring.datasource.url=jdbc:mysql://localhost:3306/Schema_Name?serverTimezone=UTC&amp;createDatabaseIfNotExist=true&#10;spring.datasource.username=root&#10;spring.datasource.password=smdesktop1234&#10;spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver&#10;&#10;spring.jpa.hibernate.ddl-auto=create-drop&#10;spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect&#10;spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true&#10;// spring.datasource.hikari.maximumPoolSize=5&#10;// spring.jackson.serialization.fail-on-empty-beans=false // In case we get a serialization error with http request for getting single object by id&#10; " description="A few common spring-setup properties" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="sm::sql::connectionPool" value="public class ConnectionPool {&#10;    &#10;    private static final int NUM_OF_CONS = 10;&#10;    private static ConnectionPool instance = null;&#10;    private final Stack&lt;Connection&gt; connections = new Stack&lt;&gt;();&#10;&#10;    private ConnectionPool() throws SQLException {&#10;        openAllConnections();&#10;    }&#10;&#10;    public static ConnectionPool getInstance() {&#10;        if (instance == null) {&#10;            synchronized (ConnectionPool.class) {&#10;                if (instance == null) {&#10;                    try {&#10;                        instance = new ConnectionPool();&#10;                    } catch (SQLException e) {&#10;                        System.err.println(&quot;[getInstance] &quot; +e.getMessage());&#10;                    }&#10;                }&#10;&#10;            }&#10;        }&#10;        return instance;&#10;    }&#10;&#10;    public Connection getConnection() throws InterruptedException {&#10;        synchronized (connections) {&#10;            if(connections.isEmpty()) {&#10;                connections.wait();&#10;            }&#10;            return connections.pop();&#10;        }&#10;    }&#10;&#10;    public void returnConnection(Connection connection) {&#10;        synchronized (connections) {&#10;            connections.push(connection);&#10;            connections.notify();&#10;        }&#10;    }&#10;&#10;    public void openAllConnections() throws SQLException {&#10;        for (int i = 0; i &lt; NUM_OF_CONS; i++) {&#10;            connections.push(DatabaseManager.connect());&#10;        }&#10;    }&#10;&#10;    public void closeAllConnections() throws InterruptedException {&#10;        synchronized (connections) {&#10;            while(connections.size() &lt; NUM_OF_CONS) {&#10;                connections.wait();&#10;            }&#10;            connections.removeAllElements();&#10;        }&#10;    }&#10;&#10;}" description="Template of connection pool class" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::sql::DBUtils" value="&#10;import com.jb.db.ConnectionPool;&#10;import com.mysql.cj.protocol.Resultset;&#10;import java.sql.Connection;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.SQLException;&#10;import java.util.Date;&#10;import java.util.Map;&#10;&#10;public class DBUtils {&#10;&#10;    private static Connection connection;&#10;&#10;    public static void runQuery(String psQuery, Map&lt;Integer, Object&gt; params) {&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(psQuery);&#10;            params.forEach((key, value) -&gt; {&#10;                try {&#10;                    if (value instanceof Integer) {&#10;                        ps.setInt(key, (int) value);&#10;                    } else if (value instanceof Double) {&#10;                        ps.setDouble(key, (Double) value);&#10;                    } else if (value instanceof Float) {&#10;                        ps.setFloat(key, (Float) value);&#10;                    } else if (value instanceof Long) {&#10;                        ps.setLong(key, (Long) value);&#10;                    } else if (value instanceof Date) {&#10;                        ps.setDate(key, (java.sql.Date) value);&#10;                    } else if (value instanceof Boolean) {&#10;                        ps.setBoolean(key, (Boolean) value);&#10;                    } else if (value instanceof Enum) {&#10;                        ps.setObject(key, value.toString());&#10;                    } else {&#10;                        ps.setString(key, (String) value);&#10;                    }&#10;                } catch (Exception e) {&#10;                    System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;                }&#10;            });&#10;            ps.execute();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;    }&#10;&#10;    public static ResultSet runQueryGetResultSet(String psQuery, Map&lt;Integer, Object&gt; params) {&#10;        Resultset rs = null;&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(psQuery);&#10;            params.forEach((key, value) -&gt; {&#10;                try {&#10;                    if (value instanceof Integer) {&#10;                        ps.setInt(key, (int) value);&#10;                    } else if (value instanceof Double) {&#10;                        ps.setDouble(key, (Double) value);&#10;                    } else if (value instanceof Float) {&#10;                        ps.setFloat(key, (Float) value);&#10;                    } else if (value instanceof Long) {&#10;                        ps.setLong(key, (Long) value);&#10;                    } else if (value instanceof Date) {&#10;                        ps.setDate(key, (java.sql.Date) value);&#10;                    } else if (value instanceof Boolean) {&#10;                        ps.setBoolean(key, (Boolean) value);&#10;                    } else {&#10;                        ps.setString(key, (String) value);&#10;                    }&#10;                } catch (Exception e) {&#10;                    System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;                }&#10;            });&#10;            rs = (Resultset) ps.executeQuery();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;        return (ResultSet) rs;&#10;    }&#10;&#10;    public static boolean runQueryGetBool(String psQuery, Map&lt;Integer, Object&gt; params) {&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(psQuery);&#10;            params.forEach((key, value) -&gt; {&#10;                try {&#10;                    if (value instanceof Integer) {&#10;                        ps.setInt(key, (int) value);&#10;                    } else if (value instanceof Double) {&#10;                        ps.setDouble(key, (Double) value);&#10;                    } else if (value instanceof Float) {&#10;                        ps.setFloat(key, (Float) value);&#10;                    } else if (value instanceof Long) {&#10;                        ps.setLong(key, (Long) value);&#10;                    } else if (value instanceof Date) {&#10;                        ps.setDate(key, (java.sql.Date) value);&#10;                    } else if (value instanceof Boolean) {&#10;                        ps.setBoolean(key, (Boolean) value);&#10;                    } else {&#10;                        ps.setString(key, (String) value);&#10;                    }&#10;                } catch (Exception e) {&#10;                    System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;                }&#10;            });&#10;            ps.execute();&#10;            ResultSet rs = ps.executeQuery();&#10;            if (rs.next()) {&#10;                return true;&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public static void runQuery(String query) {&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(query);&#10;            ps.execute();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;    }&#10;&#10;    public static void delete(String tag, String query, int id) throws SQLException, InterruptedException {&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(query);&#10;            ps.setInt(1, id);&#10;            ps.execute();&#10;        } catch (SQLException | InterruptedException e) {&#10;            System.err.println(&quot;[delete&quot; + tag + &quot;] &quot; + e.getMessage());&#10;            throw e;&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;    }&#10;&#10;}&#10;" description="Template of DBUtils class with a few helper methods" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::binarySerialization" value="class SerializationUtils {&#10;&#10;/* &#10;* Serialization basics by JetBrains Academy - https://hyperskill.org/learn/step/8147 *&#10;&#10;The lifetime of all objects within a program is limited by the runtime.&#10;When we stop and then reopen the program, the information about previously created objects is lost.&#10;Fortunately, a program can save objects to some permanent storage like a hard drive and read them back the next time the program starts.&#10;To make a class serializable, it must implement the 'Serializable' interface.&#10;&#10;private static final long serialVersionUID = 7L; - &#10;The 'serialVersionUID' field is used to verify that the sender and the receiver of a serialized object are compatible and have loaded the classes for that object.&#10;If the version number of the sender and receiver classes don't match,&#10;then the runtime error InvalidClassException occurs.&#10;The matching of this value happens “under the hood” during serialization and deserialization.&#10;An error occurs only in cases of mismatch. &#10;&#10;Here is a small description of the given code:&#10;'FileOutputStream' and F'ileInputStream' are used for working with a file;&#10;'BufferedInputStream' and 'BufferedOutputStream' are optional but useful for speeding up the I/O operations;&#10;'ObjectOutputStream' and 'ObjectInputStream' perform serialization and deserialization of objects and also invoke wrapped streams to work with the file;&#10;both methods also close the streams to avoid resource leaks.&#10;*/&#10;&#10;    public static void serialize(Object obj, String fileName) throws IOException {&#10;    // Serialize the given object to the file&#10;        FileOutputStream fos = new FileOutputStream(fileName);&#10;        BufferedOutputStream bos = new BufferedOutputStream(fos);&#10;        ObjectOutputStream oos = new ObjectOutputStream(bos);&#10;        oos.writeObject(obj);&#10;        oos.close();&#10;    }&#10;&#10;    public static Object deserialize(String fileName) throws IOException, ClassNotFoundException {&#10;    // Deserialize to an object from the file&#10;        FileInputStream fis = new FileInputStream(fileName);&#10;        BufferedInputStream bis = new BufferedInputStream(fis);&#10;        ObjectInputStream ois = new ObjectInputStream(bis);&#10;        Object obj = ois.readObject();&#10;        ois.close();&#10;        return obj;&#10;    }&#10;}" description="Simple functions of binary serialization and deserialization functions" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::txtFileWriter" value="/*When to use each serialization:&#10;In general the important question is which client will receive the serialized objects - browsers/JavaScript engines like (node-js), Java client, unknown/multiple clients.&#10;&#10;JSON - JSON syntax is basically JavaScript and therefore any component with a JS engine will handle its parsing very well - &#10;even complicated data-structures will be converted to &quot;living&quot; objects efficiently. &#10;JSON parsers exist for practically any language and it is easy to use even when not using a JS engine, &#10;(Take Google Gson for example that is able to convert JSON into corresponding objects with ease) &#10;which makes is a good candidate for cross-language communication - for example in a messaging architecture.&#10;&#10;XML - Shares many of JSON's benefits -cross-language, lightweight, etc.&#10;Adobe Flex for example handles XML very well, even better than JSON.&#10;It's definitely an appropriate substitute for JSON. &#10;I personally prefer JSON for its JS like syntax, but XML is also good.&#10;&#10;Java Serialization - Should be considered only for Java-to-Java communication.&#10;An important note is that the class definitions should be on the sending and the receiving ends and often you wouldn't gain much by passing the entire object.&#10;I wouldn't rule out RMI as a communication protocol, it does simplify development.&#10;However the resulting application components will be hard coupled which will make it very difficult to replace.&#10;&#10;One more notes - Serialization in general has its overhead.&#10;However, when the communication is performed over a network -&#10;the bottleneck is often the network rather than the serialization/deserialization itself.&#10;&#10;--------------------------------------------------------------------------------------&#10;&#10;While serialization over the network both XML and JSON would work.&#10;It depends on the consumer of this information.&#10;&#10;If the consumer is a browser using Ajax to request some information and render something on the screen,&#10;generally JSON is the best bet as its already in Javascript object format and there is no overhead of converting to Javascript compatible objects.&#10;In fact many Ajax libs (e.g. jQuery) have good support for JSON.&#10;&#10;If you consumer is another application which may or may not be in java, &#10;then XML is the prefer serialization mechanism. Web services use XML very heavily.&#10;&#10;If your consumer is another Java program then definitely java serialization is preferred option (e.g. RMI). &#10;*/&#10;&#10;import java.io.BufferedReader;&#10;import java.io.BufferedWriter;&#10;import java.io.File;&#10;import java.io.FileReader;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;&#10;public class writtingAndReadingFromFile {&#10;&#10;&#9;public static final String PATH = &quot;&quot;;&#10;&#10;&#9;public static void write(String path, String text, boolean append) throws IOException { &#10;&#9;&#9;// false - override | true - newLine&#10;&#9;&#9;File file = new File(path);&#10;&#9;&#9;FileWriter fileWriter = new FileWriter(file, append);&#10;&#9;&#9;BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);&#10;        if(!file.exists()) {&#10;            file.createNewFile();&#10;        }&#10;    &#9;&#9;bufferedWriter.write(text);&#10;    &#9;&#9;bufferedWriter.newLine();&#10;    &#9;&#9;bufferedWriter.close();&#9;&#9;&#10;&#9;}&#10;&#10;&#9;public static void read(String path) throws IOException {&#10;&#9;&#9;File file = new File(path);&#10;&#9;&#9;FileReader fileReader = new FileReader(file);&#10;&#9;&#9;BufferedReader bufferedReader = new BufferedReader(fileReader);&#10;&#9;&#9;String txt;&#10;&#9;&#9;while ((txt = bufferedReader.readLine()) != null) {&#10;&#9;&#9;&#9;System.out.println(bufferedReader.readLine());&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;}&#10;" description="Java I/O to a txt file" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::passwordHashWithMD5" value="  public static String EncrpytPassword(String password) {&#10;&#9;&#9;String passwordToHash = &quot;password&quot;;&#10;&#9;&#9;String generatedPassword = null;&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;// Create MessageDigest instance for MD5&#10;&#9;&#9;&#9;MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);&#10;&#9;&#9;&#9;// Add password bytes to digest&#10;&#9;&#9;&#9;md.update(password.getBytes());&#10;&#9;&#9;&#9;// Get the hash's bytes&#10;&#9;&#9;&#9;byte[] bytes = md.digest();&#10;&#9;&#9;&#9;// This bytes[] has bytes in decimal format;&#10;&#9;&#9;&#9;// Convert it to hexadecimal format&#10;&#9;&#9;&#9;StringBuilder sb = new StringBuilder();&#10;&#9;&#9;&#9;for (int i = 0; i &lt; bytes.length; i++) {&#10;&#9;&#9;&#9;&#9;sb.append(Integer.toString((bytes[i] &amp; 0xff) + 0x100, 16).substring(1));&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;// Get complete hashed password in hex format&#10;&#9;&#9;&#9;generatedPassword = sb.toString();&#10;&#9;&#9;} catch (NoSuchAlgorithmException e) {&#10;&#9;&#9;&#9;e.printStackTrace();&#10;&#9;&#9;}&#10;    //System.out.println(generatedPassword);&#10;&#9;&#9;return generatedPassword;&#10;&#9;}" description="Password encryption" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::dateUtils" value="public class DateUtils {&#10;&#10;    private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;dd/MM/yyyy&quot;);&#10;&#10;    /**&#10;     * Formats the params into a date format.&#10;     */&#10;    public static Date getDate(int day, int month, int year) {&#10;        try {&#10;            return simpleDateFormat.parse(String.format(&quot;%2d/%2d/%4d&quot;, day, month, year));&#10;        } catch (ParseException e) {&#10;            System.err.println(&quot;[getDate] &quot; + e.getMessage());&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Returns the date param as a formatted date pattern 'simpleDateFormat'.&#10;     */&#10;    public static String dateFormatter(Date date) {&#10;        return simpleDateFormat.format(date);&#10;    }&#10;&#10;    /**&#10;     * Converts the data type from java.Date to sql.&#10;     */&#10;    public static java.sql.Date convertDataType(Date date) {&#10;        return new java.sql.Date(date.getTime());&#10;    }&#10;&#10;    public static LocalDate convertDataToLocalDate(Date date) { // TODO: Consider removing&#10;        return Instant.ofEpochMilli(date.getTime()).atZone(ZoneId.systemDefault()).toLocalDate();&#10;    }&#10;&#10;    public static Date convertLocalDateToDate(LocalDate date) { // TODO: Consider removing&#10;        return Date.from(Instant.from(date));&#10;    }&#10;&#10;    public static LocalDate getDateOfToday() {&#10;        return LocalDate.now();&#10;    }&#10;&#10;}&#10;/* LocalDate only:&#10;package com.jb.utils;&#10;&#10;import java.time.LocalDate;&#10;&#10;public class DateUtils {&#10;&#10;    public static LocalDate getDate(int day, int month, int year) {&#10;       return LocalDate.of(year, month, year);&#10;    }&#10;&#10;    public static java.sql.Date convertLocalDateToSQL(LocalDate date) {&#10;        return java.sql.Date.valueOf(date);&#10;    }&#10;&#10;    public static String beautifyDate(LocalDate date) {&#10;        return String.format(&quot;%02d/%02d/%04d&quot;, date.getDayOfMonth(), date.getMonthValue(), date.getYear());&#10;    }&#10;&#10;    public static LocalDate convertSQLDateToLocalDate(java.sql.Date date) {&#10;        return LocalDate.parse((CharSequence) date);&#10;    }&#10;}&#10;*/&#10;" description="Class which contains a few converting methods between different date types" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::getLocalIpAddress" value="&#10;import java.net.InetAddress;&#10;&#10;class IPAddressExample {&#10;    public static void main(String args[]) throws Exception {&#10;        InetAddress inetAddress = InetAddress.getLocalHost();&#10;        System.out.println(&quot;IP Address:- &quot; + inetAddress.getHostAddress());&#10;        System.out.println(&quot;Host Name:- &quot; + inetAddress.getHostName());&#10;    }&#10;}&#10;&#10;// +-----------------------------------------------------------------------------------------------------------------------------------------------------------------+&#10;&#10;// Java program to find IP address of your computer&#10;// java.net.InetAddress class provides method to get&#10;// IP of any host name&#10;import java.net.*;&#10;        import java.io.*;&#10;        import java.util.*;&#10;        import java.net.InetAddress;&#10;&#10;public class JavaProgram&#10;{&#10;    public static void main(String args[]) throws Exception&#10;    {&#10;        // Returns the instance of InetAddress containing&#10;        // local host name and address&#10;        InetAddress localhost = InetAddress.getLocalHost();&#10;        System.out.println(&quot;System IP Address : &quot; +&#10;                (localhost.getHostAddress()).trim());&#10;&#10;        // Find public IP address&#10;        String systemipaddress = &quot;&quot;;&#10;        try&#10;        {&#10;            URL url_name = new URL(&quot;http://bot.whatismyipaddress.com&quot;);&#10;&#10;            BufferedReader sc =&#10;                    new BufferedReader(new InputStreamReader(url_name.openStream()));&#10;&#10;            // reads system IPAddress&#10;            systemipaddress = sc.readLine().trim();&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            systemipaddress = &quot;Cannot Execute Properly&quot;;&#10;        }&#10;        System.out.println(&quot;Public IP Address: &quot; + systemipaddress +&quot;\n&quot;);&#10;    }&#10;}&#10;" description="Simple function to return Ip address" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::binaryBaseConverter" value="&#9;public static void makeBinaryArray(int num) {&#10;&#9;    if(num&gt;=0 &amp;&amp; num&lt;=255) {&#10;&#9;    &#9;int[] byteArray = new int[8];&#10;&#9;     &#9;int byteIdx = byteArray.length - 1;&#10;&#9;    &#9;int counter = 0;&#10;&#9;    &#9;while (byteIdx &gt;= 0) {&#10;&#9;    &#9;&#9;int dropDown = (int) Math.pow(2, byteIdx);&#10;&#9;&#9;&#9;    if (num &gt;= 0 &amp;&amp; num &gt;= dropDown) {&#10;&#9;&#9;&#9;    &#9;byteArray[counter] = 1;&#10;&#9;&#9;&#9;    &#9;num -= dropDown;&#10;&#9;&#9;&#9;    }&#10;&#9;&#9;&#9;    counter++;&#10;&#9;&#9;&#9;    byteIdx--;&#10;&#9;&#9;    }&#10;&#9;&#9;    for (int i = 0; i &lt; byteArray.length; i++) {&#10;&#9;&#9;    &#9;System.out.print(byteArray[i] + &quot; &quot;);&#10;&#9;&#9;     }&#10;    &#9;} else {&#10;&#9;    &#9; System.out.println(&quot;- Error - \nOops, somthing went wrong! \nPlease make sure that your number is between 0-255 and try again&quot;);&#10;&#9; }&#10;&#9;}&#10;&#10;&#10;-------------------------------------------------------------------------------------&#10;&#10;&#9;public static int[] convertNumTo8BitsArrays(int num) {&#10;&#9;&#9;int[] bits = new int[8];&#10;&#9;&#9;for (int i = 0; i &lt; bits.length; i++) {&#10;&#9;&#9;&#9;int down = (int) Math.pow(2, (bits.length - 1) - i);&#10;&#9;&#9;&#9;if (num &gt;= 0 &amp;&amp; num &gt;= down) {&#10;&#9;&#9;&#9;&#9;num -= down;&#10;&#9;&#9;&#9;&#9;bits[i] = 1;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;return bits;&#10;&#9;}&#10;&#10;&#9;public static int convert8BitsArrayToInt(int[] bits) {&#10;&#9;&#9;int sum = 0;&#10;&#9;&#9;for (int i = bits.length - 1; i &gt;= 0; i--) {&#10;&#9;&#9;&#9;if (bits[i] == 1) {&#10;&#9;&#9;&#9;&#9;int add = (int) (Math.pow(2, bits.length-1-i));&#10;&#9;&#9;&#9;&#9;sum += add;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return sum;&#10;&#9;}&#10;&#10;&#9;public static void print(int[] arr) {&#10;&#9;&#9;for (int i = 0; i &lt; arr.length; i++) {&#10;&#9;&#9;&#9;System.out.print(arr[i] + &quot; &quot;);&#10;&#9;&#9;}&#10;&#9;&#9;System.out.println();&#10;&#9;}&#10;&#10;" description="Simple function to return binary base from an integer" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::task" value="import lombok.RequiredArgsConstructor;&#10;import org.springframework.scheduling.annotation.Scheduled;&#10;import org.springframework.stereotype.Component;&#10;&#10;@Component&#10;@RequiredArgsConstructor&#10;public class DailyInterviewProcessor {&#10;&#10;    private final BeanRepo beanRepo;&#10;    private static final int DAY = 1000 * 60 * 60 * 24;&#10;    private static final int DEVELOPER_TEST = 1000 * 60;&#10;&#10;    @Scheduled(fixedRate = DEVELOPER_TEST)&#10;    public void run() {&#10;        // Insert task here&#10;    }&#10;    &#10;}&#10;" description="Prototype for Spring task" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::passwordEncoder" value="    package x.security;&#10;&#10;    import org.springframework.context.annotation.Configuration;&#10;    &#10;    @Configuration&#10;    public class PasswordConfig() {&#10;&#10;        @Bean&#10;        public PasswordEncoder encoder() {&#10;            return new BCryptPasswordEncoder(10); // Empty constractur works too.&#10;        }&#10;    &#10;    }&#10;    &#10;    /*&#10;    &#10;    public void setPassword(String password) { // Setter injection in the bean itself&#10;        this.password = encoder().encode(password);&#10;    }&#10;    &#10;     */&#10;" description="Spring security password encoding with BCRYPT" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::appSecurityConfig" value="/* This class defines a base64 authentication with spring boot.&#10;   User have to log-in in every single http request beside those mentiond in 'antMatchers'.&#10;*/&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;&#10;&#10;@Configuration&#10;@EnableWebSecurity&#10;public class ApplicationSecurityConfig extends WebSecurityConfigurerAdapter {&#10;&#10;    @Override&#10;    protected void configure(HttpSecurity http) throws Exception {&#10;        http&#10;                .authorizeRequests()&#10;                .antMatchers(&quot;/&quot;, &quot;index&quot;, &quot;/css/*&quot;, &quot;/js/*&quot;) // The file endings that wont need to login with user and password&#10;                .permitAll()&#10;                .anyRequest()&#10;                .authenticated()&#10;                .and()&#10;                .httpBasic();&#10;    }&#10;&#10;}" description="Spring security config" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::advice" value="import com.example.PreTestHomeWork2.exceptions.CatsException;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.web.bind.annotation.ControllerAdvice;&#10;import org.springframework.web.bind.annotation.ExceptionHandler;&#10;import org.springframework.web.bind.annotation.ResponseStatus;&#10;import org.springframework.web.bind.annotation.RestController;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@RestController&#10;@ControllerAdvice&#10;public class ErrorDetails {&#10;&#10;    private String key;&#10;    private String value;&#10;&#10;    @ExceptionHandler(value = {CatsException.class})&#10;    @ResponseStatus(code = HttpStatus.BAD_REQUEST)&#10;    public ErrorDetails handleException(Exception e) {&#10;            return new ErrorDetails(&quot;[Error]&quot;, e.getMessage());&#10;        }&#10;&#10;}" description="Advice handler class to manage all exceptions classes" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::setSwaggerConfiguration" value="/* &#10; *Maven Dependencies:&#10; &lt;dependenices&gt;&#10;&#9;&#9;&#9;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;&#10;&#9;&#9;&#9;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;&#10;&#9;&#9;&#9;    &lt;version&gt;2.9.2&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&#9;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;&#10;&#9;&#9;&#9;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;&#10;&#9;&#9;&#9;    &lt;version&gt;2.9.2&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&lt;/dependenices&gt;&#10;&#10; *Enjoy:&#10;  http://localhost:8080/swagger-ui.html&#10;*/&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import springfox.documentation.builders.PathSelectors;&#10;import springfox.documentation.builders.RequestHandlerSelectors;&#10;import springfox.documentation.spi.DocumentationType;&#10;import springfox.documentation.spring.web.plugins.Docket;&#10;import springfox.documentation.swagger2.annotations.EnableSwagger2;&#10;&#10;@Configuration&#10;@EnableSwagger2&#10;public class SwaggerConfiguration {&#10;&#10;    @Bean&#10;    public Docket api() {&#10;        return new Docket(DocumentationType.SWAGGER_2)&#10;                .select()&#10;                .apis(RequestHandlerSelectors.any())&#10;                .paths(PathSelectors.any())&#10;                .build();&#10;    }&#10;&#10;}" description="Http client" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::beanControllerTesting" value="import lombok.RequiredArgsConstructor;&#10;import org.springframework.boot.CommandLineRunner;&#10;import org.springframework.core.annotation.Order;&#10;import org.springframework.http.HttpEntity;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;@Order(2)&#10;@RequiredArgsConstructor&#10;@Component&#10;public class BeanControllerTesting implements CommandLineRunner {&#10;    &#10;/* &#10;package config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;@Configuration&#10;public class WebConfig {&#10;&#10;    @Bean&#10;    public RestTemplate RestTemplate() {&#10;        return new RestTemplate();&#10;    }&#10;}&#10;*/&#10;&#10;    private final RestTemplate restTemplate;&#10;    private final Service service;&#10;    private static String URL = &quot;http://localhost:8080/X&quot;;&#10;&#10;    @Override&#10;    public void run(String... args) throws Exception {&#10;&#10;        System.out.println(&quot;---------------------------------------------------------------------------------------------------------------------&quot;);&#10;         /* Note:&#10;             1) In order to have 'true' values,&#10;                Compare the HttpStatus.Enum for each method test here with the Enum selected in the controller.&#10;             2) Compare method names with the string added to the url in each http method here.&#10;             3) Change PathVariable value(currently - 1) if necessary&#10;          */&#10;&#10;        // POST&#10;        Bean toAdd = new Bean();&#10;        ResponseEntity&lt;String&gt; postResult = restTemplate.postForEntity(URL + &quot;/add&quot;, toAdd, String.class);&#10;        System.out.println(postResult.getStatusCodeValue() == HttpStatus.CREATED.value());&#10;        System.out.println(&quot;POST response: &quot; + postResult);&#10;&#10;        // PUT&#10;        service.add(toAdd);&#10;        toAdd.setName(&quot;Shay&quot;);&#10;        HttpEntity&lt;?&gt; updateRequest = new HttpEntity&lt;&gt;(toAdd);&#10;        ResponseEntity&lt;String&gt; putResult = restTemplate.exchange(URL + &quot;/update&quot;, HttpMethod.PUT, updateRequest, String.class);&#10;        System.out.println(&quot;PUT response: &quot; + putResult);&#10;        System.out.println(putResult.getStatusCodeValue() == HttpStatus.NO_CONTENT.value());&#10;&#10;        // GET&#10;        System.out.println(&quot;GET response: &quot; + restTemplate.getForObject(URL + &quot;/getSingle&quot;, String.class));&#10;&#10;        // GET ALL&#10;/*&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class BeanList {private List&lt;Bean&gt; bean = new ArrayList();} */&#10;        BeanList res = restTemplate.getForObject(URL + &quot;/getAll&quot;, BeanList.class);&#10;        res.get().forEach(System.out::println);&#10;        &#10;        // DELETE&#10;        HttpEntity&lt;?&gt; deleteRequest = new HttpEntity&lt;&gt;(toAdd);&#10;        ResponseEntity&lt;String&gt; deleteResult = restTemplate.exchange(URL + &quot;/deleteById/{id}&quot;, HttpMethod.DELETE, deleteRequest, String.class, 1);&#10;        System.out.println(&quot;DELETE response: &quot; + deleteResult);&#10;        System.out.println(deleteResult.getStatusCodeValue() == 204);&#10;&#10;    }" description="Spring clr - A coded version of HTTP client using RestTemplate" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::TokenManager" value="import com.sm.demo.constants.ServerConstants;&#10;import com.sm.demo.service.ClientService;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Component;&#10;import java.time.LocalDateTime;&#10;import java.util.Map;&#10;import java.util.UUID;&#10;&#10;@Component&#10;@RequiredArgsConstructor&#10;public class TokenManager {&#10;&#10;    private final Map&lt;String, Information&gt; tokenContainer;&#10;&#10;    public String generateToken(ClientService clientService) {&#10;        String token = UUID.randomUUID().toString();&#10;        Information information = Information.builder()&#10;                .clientService(clientService)&#10;                .time(LocalDateTime.now())&#10;                .build();&#10;        tokenContainer.put(token, information);&#10;        return token;&#10;    }&#10;&#10;    public void deleteToken(String token) {&#10;        tokenContainer.remove(token);&#10;    }&#10;&#10;    public boolean isExist(String token) {&#10;        return tokenContainer.get(token) != null;&#10;    }&#10;&#10;    public void removeExpired() {&#10;        tokenContainer.entrySet().removeIf(TokenManager::removeExpired);&#10;    }&#10;&#10;    private static boolean removeExpired(Map.Entry&lt;String, Information&gt; entry) {&#10;        return entry.getValue().getTime().isBefore(LocalDateTime.now().minusMinutes(ServerConstants.DEVELOPER_TEST_FOR_TOKEN_EXPIRATION_TIME));&#10;    }&#10;&#10;    public void updateLastActionTime(String token) {&#10;        tokenContainer.get(token).setTime(LocalDateTime.now());&#10;    }&#10;&#10;}&#10;&#10;&#10;&#10;/* RemoveExpiredTokens - task:&#10;&#10;import com.sm.demo.constants.ServerConstants;&#10;import com.sm.demo.security.TokenManager;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.scheduling.annotation.Scheduled;&#10;import org.springframework.stereotype.Component;&#10;&#10;@Component&#10;@RequiredArgsConstructor&#10;public class RemoveExpiredToken {&#10;&#10;    private final TokenManager tokenManager;&#10;&#10;    @Scheduled(fixedRate = ServerConstants.TOKEN_TASK_TIME)&#10;    public void removeExpiredTokens() {&#10;        tokenManager.removeExpired();&#10;    }&#10;}&#10; */&#10;&#10;/* Inside each service method:&#10;        if(!tokenManager.isExist(token)) {&#10;            throw new SecurityException(&quot;Invalid token...&quot;);&#10;        }&#10;        tokenManager.updateLastActionTime(token)&#10; */&#10;&#10;/* Http method example:&#10;    @PutMapping(&quot;/update&quot;)&#10;    @ResponseStatus(HttpStatus.ACCEPTED)&#10;    void update(@RequestHeader(value = &quot;Authorization&quot;) String token, @RequestBody Company company) throws InvalidOperationHandler, InvalidEntityHandler {&#10;        companyServiceImpl.updateProfile(company, token);&#10;    }&#10; */&#10;&#10;/* LoginManager:&#10;@Service&#10;@RequiredArgsConstructor&#10;public class LoginManager {&#10;&#10;    private final ApplicationContext ctx;&#10;    private final TokenManager tokenManager;&#10;&#10;    public String login(String email, String password, ClientTypes clientType) {&#10;        switch (clientType) {&#10;            case ACCOUNT:&#10;                AccountServiceImpl accountServiceImpl = ctx.getBean(AccountServiceImpl.class);&#10;                if (accountServiceImpl.login(email, password)) {&#10;                    return tokenManager.generateToken(accountServiceImpl);&#10;                }&#10;            case COMPANY:&#10;                CompanyServiceImpl companyServiceImpl = ctx.getBean(CompanyServiceImpl.class);&#10;                if (companyServiceImpl.login(email, password)) {&#10;                    return tokenManager.generateToken(companyServiceImpl);&#10;                }&#10;        }&#10;        throw new SecurityException(&quot;Invalid email and password combination.&quot;);&#10;    }&#10;&#10;}&#10; */" description="Template for token handling *without* Spring" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::stamp" value="/* @File created by Shay Marko&#10;     * File: filePath().fileName()&#10;     * Timestamp: date(&quot;Y-MM-d, E, H:m&quot;)&#10;     * Description: &#10;*/" description="Developer stamp for a new class" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::simpleEntity" value="import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import javax.persistence.Entity;&#10;import javax.persistence.GeneratedValue;&#10;import javax.persistence.GenerationType;&#10;import javax.persistence.Id;&#10;&#10;@Entity&#10;@Data&#10;@NoArgsConstructor&#10;public class Bean {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY) // Each obj gets his own key&#10;    private int Id;&#10;&#10;}&#10;" description="Prototype for spring entity" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::simpleException" value="public class BeanException extends Exception {&#10;&#10;    public BeanException(String msg) {&#10;        super(msg);&#10;    }&#10;&#10;}" description="Prototype of exception class" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::REGEX" value="    private static final String PASSWORD_REGEX = &quot;^(?=.*?[A-Z])(?=(.*[a-z]){1,})(?=(.*[\\d]){1,})(?=(.*[\\W]){1,})(?!.*\\s).{8,}$&quot;;&#10;//    This regex will enforce these rules:&#10;//    At least one upper case English letter&#10;//    At least one lower case English letter&#10;//    At least one digit&#10;//    At least one special character&#10;//    Minimum eight in length&#10;    private static final String EMAIL_REGEX = &quot;/^[a-zA-Z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/&quot;;&#10;//    A valid e-mail address is a string that matches the ABNF production […].&#10;//    Note: This requirement is a willful violation of RFC 5322, which defines a syntax for e-mail addresses that is simultaneously too strict (before the “@” character), too vague (after the “@” character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.&#10;//    The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.&#10;" description="Regex patterns for email&amp;password" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::loggerHandler" value="import com.sm.demo.constants.ServerConstants;&#10;import com.sm.demo.exception.InvalidServerHandler;&#10;import java.io.IOException;&#10;import java.util.logging.*;&#10;&#10;@Component&#10;    public class LoggerHandler {&#10;&#10;        /* Level table:&#10;            Level&#9;Value&#9;Used for&#10;            +-----------------------+&#10;            SEVERE&#9;1000&#9;Indicates some serious failure&#10;            WARNING&#9;900&#9;Potential Problem&#10;            INFO&#9;800&#9;General Info&#10;            CONFIG&#9;700&#9;Configuration Info&#10;            FINE&#9;500&#9;General developer info&#10;            FINER&#9;400&#9;Detailed developer info&#10;            FINEST&#9;300&#9;Specialized Developer Info&#10;        */&#10;            /* External Classes:&#10;         - ServerConstants:&#10;             // Logger&#10;             public static final String LOGGER_NAME = &quot;ServerLog&quot;;&#10;             public static final String LOGGER_FILE_NAME = &quot;InterviewSimulator_logger&quot;;&#10;             public static final String LOGGER_PATH = &quot;/Users/smarko/Desktop/&quot; +LOGGER_FILE_NAME+ &quot;.log&quot;;&#10;         - logging.properties:&#10;             #logging.file=/Users/smarko/Desktop/ServerLog.log&#10;             #handlers= java.util.logging.ConsoleHandler&#10;             #.level= INFO&#10;             #java.util.logging.ConsoleHandler.formatter=%d{yyyy-MM-dd HH:mm:ss} - %msg%n&#10;             #java.util.logging.ConsoleHandler.level = INFO&#10;             #java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter&#10;&#10;             java.util.logging.FileHandler.pattern=/Users/smarko/Desktop/ServerLog.log&#10;             java.util.logging.FileHandler.limit=50000&#10;             java.util.logging.FileHandler.count=1&#10;             java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter&#10;             .level = INFO&#10;             handlers= java.util.logging.FileHandler, java.util.logging.ConsoleHandler  &#10;     */&#10;&#10;        private static Logger logger = Logger.getLogger(ServerConstants.LOGGER_NAME);&#10;        private static FileHandler fh;&#10;&#10;        public static void setLogProperties() throws InvalidServerHandler {&#10;            try {&#10;                fh = new FileHandler(ServerConstants.LOGGER_PATH);&#10;                logger.addHandler(fh);&#10;                fh.setFormatter(new SimpleFormatter());&#10;            } catch (SecurityException | IOException e) {&#10;                throw new InvalidServerHandler(&quot;Failed to initialize server log. \nReason: &quot; + e.getMessage());&#10;            }&#10;        }&#10;&#10;        public void createLog(Level lvl, String msg) {&#10;            logger.log(lvl, msg);&#10;        }&#10;&#10;    }&#10;&#10;&#10;//    public static void setLogProperties() throws InvalidServerHandler {&#10;//        logger.setLevel(Level.ALL);&#10;//        logger.info(&quot;initializing - trying to load configuration file ...&quot;);&#10;//        //Properties preferences = new Properties();&#10;//        try {&#10;//            //FileInputStream configFile = new //FileInputStream(&quot;/path/to/app.properties&quot;);&#10;//            //preferences.load(configFile);&#10;//            InputStream configFile = LoggerHandler.class.getResourceAsStream(&quot;src/main/resources/logging.properties&quot;);&#10;//            LogManager.getLogManager().readConfiguration(configFile);&#10;//        } catch (IOException ex) {&#10;//            System.err.println(&quot;WARNING: Logging not configured (console output only)&quot;);&#10;//            throw new InvalidServerHandler(&quot;WARNING: Could not open configuration file \nReason: &quot; + ex.getMessage());&#10;//        }&#10;//        createLog(Level.INFO, &quot;Server started&quot;);&#10;//    }" description="Template of logging system to a txt file" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::jsonToPojo" value="public ApiConvertor converter(String jsonData) throws JsonProcessingException {&#10;        /* If not using spring boot:&#10;             - Add dependency: &#10;                  &lt;dependency&gt;&#10;                    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;&#10;                    &lt;artifactId&gt;gson&lt;/artifactId&gt;&#10;                    &lt;version&gt;2.8.5&lt;/version&gt;&#10;                  &lt;/dependency&gt;&#10;             - import com.google.gson.Gson;&#10;             - return new Gson().fromJson(jsonData, ApiConvertor.class);&#10;         */&#10;    // Inside class: private final ObjectMapper objectMapper;&#10;    ObjectMapper mapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);&#10;    return mapper.readValue(jsonData, ApiConvertor.class);&#10;}&#10;" description="Converts json data to a bean object using Spring Boot / Gson library" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::security" value="package com.sm.demo.security;&#10;&#10;public class SpringSecurity {&#10;&#10;/* SecurityConfig:&#10;package com.sm.demo.security.config;&#10;&#10;import com.sm.demo.security.service.ApplicationUserService;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.authentication.dao.DaoAuthenticationProvider;&#10;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;&#10;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.util.matcher.AntPathRequestMatcher;&#10;&#10;@Configuration&#10;@EnableWebSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig extends WebSecurityConfigurerAdapter {&#10;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final ApplicationUserService applicationUserService;&#10;&#10;    @Override&#10;    protected void configure(HttpSecurity http) throws Exception {&#10;        http&#10;                .csrf().disable()&#10;//                 .csrf().csrfTokenRepository((CookieCsrfTokenRepository.withHttpOnlyFalse())).and()&#10;                .authorizeRequests()&#10;                     .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) // Decides which ROLE has access to which api&#10;                     .antMatchers(&quot;/company/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;COMPANY&quot;)&#10;                     .antMatchers(&quot;/student/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;STUDENT&quot;)&#10;//                   Another way to attach each ROLE to his HTTP methods,&#10;//                   is by allowing the most basic role entering every api(ex: '.antMatchers(&quot;/api/**&quot;).hasRole(MOST_BASIC.getGrantedAuthorities())')&#10;//                   and do the filter itself on the method level inside the controller using the annotations:&#10;//                     * @PreAuthorize(&quot;hasAnyRole('ROLE_STUDENT', 'ROLE_ADMIN')&quot;)&#10;//                     * @preAuthorise('hasRole('')&quot;)&#10;//                     * same goes for hasAuthority / hasAnyaAuthority&#10;//                     In order to implement this way, annotate SecurityConfig class with '@EnableGlobalMethodSecurity(prePostEnabled = true)'&#10;                     .antMatchers(&quot;/&quot;, &quot;index&quot;, &quot;/css/*&quot;, &quot;/js/*&quot;).permitAll()&#10;                     .anyRequest()&#10;                     .authenticated()&#10;                .and().formLogin()&#10;                     .loginPage(&quot;/login&quot;) // define which custom login page we will have..dont forget to create view api &amp; html page&#10;                     .permitAll() // permits customized pages&#10;                     .defaultSuccessUrl(&quot;/panel&quot;, true) // Default page to re-direct after logging-in&#10;                   .failureUrl(&quot;/error.html&quot;)&#10;                    .usernameParameter(&quot;username&quot;)// changing the custom-html page params requires changing it here as well(so spring would know where to attack each param value)&#10;                    .passwordParameter(&quot;password&quot;)&#10;                .and().rememberMe()&#10;                    .rememberMeParameter(&quot;remember-me&quot;) // key name for the cookie inside the browser engine&#10;                    .tokenValiditySeconds(ServerConstants.REMEMBER_ME) // expiration time for the remember me&#10;                    .key(&quot;&quot;) // ??&#10;                    .failureUrl(&quot;/login.html?error=true&quot;)&#10;                    .failureHandler(authenticationFailureHandler())&#10;                 .and().logout()&#10;                     .logoutUrl(&quot;/logout&quot;) // define which custom logout page we will have..dont forget to create view api &amp; html page&#10;                     .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;, &quot;GET&quot;)) // https://docs.spring.io/spring-security/site/docs/4.2.12.RELEASE/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html&#10;            .clearAuthentication(true) // clears authentication data after logging-out&#10;                     .invalidateHttpSession(true)&#10;                     .deleteCookies(&quot;JSESSIONID&quot;, &quot;remember-me&quot;) // deletes the following cookies when logging out&#10;                     .logoutSuccessUrl(&quot;/index&quot;); // Default page to re-direct after logging-out&#10;}&#10;&#10;    @Override&#10;    protected void configure(AuthenticationManagerBuilder auth) throws Exception {&#10;        auth.authenticationProvider(daoAuthenticationProvider());&#10;    }&#10;&#10;    @Bean&#10;    public DaoAuthenticationProvider daoAuthenticationProvider() {&#10;        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();&#10;        provider.setPasswordEncoder(passwordEncoder);&#10;        provider.setUserDetailsService(applicationUserService);&#10;        return provider;&#10;    }&#10;&#10;}&#10;**/&#10;&#10;/* PasswordConfig:&#10;package com.sm.demo.security.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;@Configuration&#10;public class PasswordConfig {&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder(10);&#10;    }&#10;}&#10;**/&#10;&#10;/* UserAvailablePermissions:&#10;package com.sm.demo.security.authorities;&#10;&#10;public enum UserAvailablePermissions {&#10;&#10;    STUDENT_UPDATE(&quot;student:update&quot;),&#10;    STUDENT_DELETE(&quot;student:delete&quot;),&#10;    STUDENT_CREATE_FORM(&quot;student:createForm&quot;),&#10;    COMPANY_UPDATE(&quot;company:update&quot;),&#10;    COMPANY_ADD_QUESTION(&quot;company:addQuestion&quot;),&#10;    COMPANY_UPDATE_QUESTION(&quot;company:updateQuestion&quot;),&#10;    COMPANY_DELETE(&quot;company:delete&quot;),&#10;    GET_NOTIFICATION(&quot;get:notification&quot;),&#10;    SEND_NOTIFICATION(&quot;send:notification&quot;);&#10;&#10;    private final String permission;&#10;&#10;    UserAvailablePermissions(String permission) {&#10;        this.permission = permission;&#10;    }&#10;&#10;    public String getPermission() {&#10;        return permission;&#10;    }&#10;&#10;}&#10;**/&#10;&#10;/* UserRole:&#10;package com.sm.demo.security.authorities;&#10;&#10;import com.google.common.collect.Sets;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import java.util.Set;&#10;import java.util.stream.Collectors;&#10;import static com.sm.demo.security.authorities.UserAvailablePermissions.*;&#10;&#10;public enum UserRole {&#10;&#10;    STUDENT(Sets.newHashSet(STUDENT_UPDATE, STUDENT_CREATE_FORM, STUDENT_DELETE, SEND_NOTIFICATION, GET_NOTIFICATION)),&#10;    COMPANY(Sets.newHashSet(COMPANY_UPDATE, COMPANY_ADD_QUESTION, COMPANY_UPDATE_QUESTION, COMPANY_DELETE, SEND_NOTIFICATION, GET_NOTIFICATION)),&#10;    ADMIN(Sets.newHashSet(COMPANY_UPDATE, COMPANY_DELETE, STUDENT_UPDATE, STUDENT_DELETE, SEND_NOTIFICATION, GET_NOTIFICATION));&#10;&#10;    private final Set&lt;UserAvailablePermissions&gt; permissions;&#10;&#10;    UserRole(Set&lt;UserAvailablePermissions&gt; permissions) {&#10;        this.permissions = permissions;&#10;    }&#10;&#10;    public Set&lt;UserAvailablePermissions&gt; getPermissions() {&#10;        return permissions;&#10;    }&#10;&#10;    public Set&lt;SimpleGrantedAuthority&gt; getGrantedAuthorities() {&#10;        Set&lt;SimpleGrantedAuthority&gt; permissions = getPermissions().stream()&#10;                .map(permission -&gt; new SimpleGrantedAuthority(permission.getPermission()))&#10;                .collect(Collectors.toSet());&#10;        permissions.add(new SimpleGrantedAuthority(&quot;ROLE_&quot; + this.name()));&#10;        return permissions;&#10;    }&#10;&#10;}&#10;**/&#10;&#10;/* UserRepo:&#10;package com.sm.demo.security.repo;&#10;&#10;import com.sm.demo.security.auth.MyUserDetails;&#10;import java.util.Optional;&#10;&#10;public interface UserRepo {&#10;&#10;    Optional&lt;MyUserDetails&gt; selectUserByUsername(String username);&#10;&#10;}&#10;**/&#10;&#10;/* MyUserDetails:&#10;package com.sm.demo.security.auth;&#10;&#10;import org.springframework.security.core.GrantedAuthority;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import java.util.Collection;&#10;import java.util.Set;&#10;&#10;public class MyUserDetails implements UserDetails {&#10;&#10;    private final String username;&#10;    private final String password;&#10;    private final Set&lt;? extends GrantedAuthority&gt; grantedAuthorities;&#10;    private final boolean isAccountNonExpired;&#10;    private final boolean isAccountNonLocked;&#10;    private final boolean isCredentialsNonExpired;&#10;    private final boolean isEnabled;&#10;&#10;    public MyUserDetails(String username,&#10;                         String password,&#10;                         Set&lt;? extends GrantedAuthority&gt; grantedAuthorities,&#10;                         boolean isAccountNonExpired,&#10;                         boolean isAccountNonLocked,&#10;                         boolean isCredentialsNonExpired,&#10;                         boolean isEnabled) {&#10;        this.username = username;&#10;        this.password = password;&#10;        this.grantedAuthorities = grantedAuthorities;&#10;        this.isAccountNonExpired = isAccountNonExpired;&#10;        this.isAccountNonLocked = isAccountNonLocked;&#10;        this.isCredentialsNonExpired = isCredentialsNonExpired;&#10;        this.isEnabled = isEnabled;&#10;    }&#10;&#10;    @Override&#10;    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {&#10;        return grantedAuthorities;&#10;    }&#10;&#10;    @Override&#10;    public String getPassword() {&#10;        return password;&#10;    }&#10;&#10;    @Override&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonExpired() {&#10;        return isAccountNonExpired;&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonLocked() {&#10;        return isAccountNonLocked;&#10;    }&#10;&#10;    @Override&#10;    public boolean isCredentialsNonExpired() {&#10;        return isCredentialsNonExpired;&#10;    }&#10;&#10;    @Override&#10;    public boolean isEnabled() {&#10;        return isEnabled;&#10;    }&#10;}&#10;**/&#10;&#10;/* ApplicationUserService:&#10;package com.sm.demo.security.service;&#10;&#10;import com.sm.demo.login.LoginManager;&#10;import com.sm.demo.security.repo.UserRepo;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.beans.factory.annotation.Qualifier;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import org.springframework.security.core.userdetails.UserDetailsService;&#10;import org.springframework.security.core.userdetails.UsernameNotFoundException;&#10;import org.springframework.stereotype.Service;&#10;&#10;@Service&#10;public class ApplicationUserService implements UserDetailsService {&#10;&#10;    private final UserRepo userRepo;&#10;    private final LoginManager loginManager;&#10;&#10;    @Autowired&#10;    public ApplicationUserService(@Qualifier(&quot;usersFromDB&quot;) UserRepo userRepo, LoginManager loginManager) {&#10;        this.userRepo = userRepo;&#10;        this.loginManager = loginManager;&#10;    }&#10;&#10;    @Override&#10;    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {&#10;        loginManager.login(email);&#10;        return userRepo&#10;                .selectUserByUsername(email)&#10;                .orElseThrow(() -&gt;&#10;                        new UsernameNotFoundException(String.format(&quot;User %s not found&quot;, email))&#10;                );&#10;    }&#10;&#10;}&#10;**/&#10;&#10;/* AppUserDAOService&#10;package com.sm.demo.security.service;&#10;&#10;import com.sm.demo.constants.ServerConstants;&#10;import com.sm.demo.repo.CompanyRepo;&#10;import com.sm.demo.repo.StudentRepo;&#10;import com.sm.demo.security.auth.MyUserDetails;&#10;import com.sm.demo.security.repo.UserRepo;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Repository;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import static com.sm.demo.security.authorities.UserRole.*;&#10;&#10;@Repository(&quot;usersFromDB&quot;)&#10;@RequiredArgsConstructor&#10;public class AppUserDAOService implements UserRepo {&#10;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final CompanyRepo companyRepo;&#10;    private final StudentRepo studentRepo;&#10;&#10;    @Override&#10;    public Optional&lt;MyUserDetails&gt; selectUserByUsername(String username) {&#10;        return getApplicationUsers()&#10;                .stream()&#10;                .filter(applicationUser -&gt; username.equals(applicationUser.getUsername()))&#10;                .findFirst();&#10;    }&#10;&#10;    private List&lt;MyUserDetails&gt; getApplicationUsers() {&#10;        List&lt;MyUserDetails&gt; applicationUsers = new ArrayList&lt;&gt;();&#10;        applicationUsers.add(new MyUserDetails(&#10;                ServerConstants.ADMIN_EMAIL,&#10;                passwordEncoder.encode(ServerConstants.ADMIN_PASSWORD),&#10;                ADMIN.getGrantedAuthorities(),&#10;                true,&#10;                true,&#10;                true,&#10;                true&#10;        ));&#10;        companyRepo.findAll().forEach((c) -&gt; {&#10;                    applicationUsers.add(new MyUserDetails(&#10;                            c.getEmail(),&#10;                            passwordEncoder.encode(c.getPassword()),&#10;                            COMPANY.getGrantedAuthorities(),&#10;                            true,&#10;                            true,&#10;                            true,&#10;                            true&#10;                    ));&#10;                });&#10;        studentRepo.findAll().forEach((s) -&gt; {&#10;            applicationUsers.add(new MyUserDetails(&#10;                    s.getEmail(),&#10;                    passwordEncoder.encode(s.getPassword()),&#10;                    STUDENT.getGrantedAuthorities(),&#10;                    true,&#10;                    true,&#10;                    true,&#10;                    true&#10;            ));&#10;        });&#10;                return applicationUsers;&#10;    }&#10;}&#10;**/&#10;&#10;/* TemplateController:&#10;package com.sm.demo.controller;&#10;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.RequestMapping;&#10;&#10;@Controller&#10;@RequestMapping(&quot;/&quot;)&#10;public class TemplateController {&#10;&#10;    @GetMapping(&quot;login&quot;)&#10;    public String getLoginView() {&#10;        return &quot;login&quot;;&#10;    }&#10;&#10;    @GetMapping(&quot;panel&quot;)&#10;    public String getPanelView() {&#10;        return &quot;panel&quot;;&#10;    }&#10;}&#10;**/&#10;&#10;/* Maven:&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;com.google.guava&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;guava&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;28.1-jre&lt;/version&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10; */&#10;&#10;/* resources -&gt; templates -&gt; index, login, panel:&#10;// index&#10;&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;en&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;    &lt;title&gt;Interview Simulator&lt;/title&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&lt;p&gt;&#10;    Welcome! Homepage - Index.&#10;&lt;/p&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;&#10;&#10;// login&#10;&lt;html&gt;&#10;&lt;head&gt;&lt;/head&gt;&#10;&lt;body&gt;&#10;&lt;h1&gt;Login&lt;/h1&gt;&#10;&lt;form action=&quot;/login&quot; method='POST'&gt;&#10;    &lt;table&gt;&#10;        &lt;tr&gt;&#10;            &lt;td&gt;User:&lt;/td&gt;&#10;            &lt;td&gt;&lt;input type='text' name='username' value=''&gt;&lt;/td&gt;&#10;        &lt;/tr&gt;&#10;        &lt;tr&gt;&#10;            &lt;td&gt;Password:&lt;/td&gt;&#10;            &lt;td&gt;&lt;input type='password' name='password' /&gt;&lt;/td&gt;&#10;        &lt;/tr&gt;&#10;        &lt;tr&gt;&#10;            &lt;td&gt;&lt;input name=&quot;submit&quot; type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/td&gt;&#10;        &lt;/tr&gt;&#10;    &lt;/table&gt;&#10;&lt;/form&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;&#10;&#10;// panel:&#10;&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;en&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;    &lt;title&gt;Title&lt;/title&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&lt;h1&gt;After-Login-Page&lt;/h1&gt;&#10;&lt;form class=&quot;form-signin&quot; method=&quot;get&quot; action=&quot;/logout&quot;&gt;&#10;    &lt;button type=&quot;submit&quot;&gt;Logout&lt;/button&gt;&#10;&lt;/form&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;&#10;**/&#10;    &#10;&#10;}&#10;" description="Full spring security implementation" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::thread" value="/*&#10;Thread thread = new Thread(new Runnable() {&#10;&#9;&#9;@Override&#10;&#9;&#9;public void run() {&#10;&#9;&#9;&#9;*//* Execution here *//*&#10;&#9;&#9;}&#10;&#9;});&#10;&#10;&#9;thread.start();&#10;&#9;thread.join(); *//* Main thread waits this thread will die before continue execution next interperter lines *//*&#10;*/&#10;&#9;new Thread(() -&gt; function()).start(); &#10;&#10;" description="Vanilla java thread structure" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::reflectionApi" value="        Class&lt;?&gt; clazz = Person.class;&#10;        System.out.println(&quot;----------Basic Meta data-----&quot;);&#10;        System.out.println(clazz.getName());&#10;        System.out.println(clazz.getPackageName());&#10;        System.out.println(clazz.getSimpleName());&#10;        System.out.println(&quot;----------Aceess Modifiers for Class Level-----&quot;);&#10;        int classModifiers = clazz.getModifiers();&#10;        System.out.println(&quot;clazz.getModifiers() &quot; + classModifiers);&#10;        System.out.println(&quot;isPublic : &quot; + Modifier.isPublic(classModifiers));&#10;        System.out.println(&quot;isFinal : &quot; + Modifier.isFinal(classModifiers));&#10;        System.out.println(&quot;isStatic : &quot; + Modifier.isStatic(classModifiers));&#10;        System.out.println(&quot;isPrivate : &quot; + Modifier.isPrivate(classModifiers));&#10;        System.out.println(&quot;isProtected : &quot; + Modifier.isProtected(classModifiers));&#10;        System.out.println(&quot;isSyncronized : &quot; + Modifier.isSynchronized(classModifiers));&#10;        System.out.println(&quot;isAbstract : &quot; + Modifier.isAbstract(classModifiers));&#10;        System.out.println(&quot;--------Super class------&quot;);&#10;        System.out.println(&quot;superclass : &quot; + clazz.getSuperclass());&#10;        System.out.println(&quot;-------- Interfaces ------&quot;);&#10;        Class[] interfaces = clazz.getInterfaces();&#10;        Arrays.stream(interfaces).forEach(System.out::println);&#10;        System.out.println(&quot;-------- CTORS ------&quot;);&#10;        Constructor[] constructors = clazz.getConstructors();&#10;        Arrays.stream(constructors).forEach(System.out::println);&#10;        System.out.println(&quot;-------- Methods ------&quot;);&#10;        Method[] methods = clazz.getMethods();&#10;        Arrays.stream(methods).forEach(method -&gt; System.out.println(method.getName() + &quot; &quot; + method.getReturnType()));&#10;        System.out.println(&quot;-------- Getters ------&quot;);&#10;        Arrays.stream(methods).filter(method -&gt; method.getName().startsWith(&quot;get&quot;)).forEach(System.out::println);&#10;        System.out.println(&quot;-------- Setters ------&quot;);&#10;        Arrays.stream(methods).filter(method -&gt; method.getName().startsWith(&quot;set&quot;)).forEach(System.out::println);&#10;        System.out.println(&quot;-------- Fields ------&quot;);&#10;        Field[] fields = clazz.getDeclaredFields();&#10;        Arrays.stream(fields).forEach(field-&gt;System.out.println(field.getName()));" description="Quick implementation for Reflection Api" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
</templateSet>