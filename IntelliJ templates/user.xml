<templateSet group="user">
  <template name="sm::general::textToAsciiConvertor" value="import java.awt.*;&#10;import java.awt.image.BufferedImage;&#10;&#10;public class Converter {&#10;&#10;    private static final int WIDTH = 100;&#10;    private static final int HEIGHT = 30;&#10;    private static final String SIGN = &quot;*&quot;;&#10;    private static final String FONT = &quot;Arial&quot;;&#10;&#10;    public static void converter(String toConvert, boolean lowerCase) {&#10;        toConvert = lowerCase ? toConvert.toLowerCase() : toConvert.toUpperCase();&#10;        BufferedImage image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);&#10;        Graphics g = image.getGraphics();&#10;        g.setFont(new Font(FONT, Font.BOLD, 24));&#10;&#10;        Graphics2D graphics = (Graphics2D) g;&#10;        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;        graphics.drawString(toConvert, 10, 20);&#10;&#10;        for (int y = 0; y &lt; HEIGHT; y++) {&#10;            StringBuilder sb = new StringBuilder();&#10;            for (int x = 0; x &lt; WIDTH; x++) {&#10;                sb.append(image.getRGB(x, y) == -16777216 ? &quot; &quot; : SIGN);&#10;            }&#10;            if (sb.toString().trim().isEmpty()) {&#10;                continue;&#10;            }&#10;            System.out.println(sb);&#10;         }&#10;    }&#10;&#10;    public static void getAllFonts() {&#10;        GraphicsEnvironment graphics = GraphicsEnvironment.getLocalGraphicsEnvironment();&#10;        Font[] fonts = graphics.getAllFonts();&#10;        for (int i = 0; i &lt; fonts.length; i++) {&#10;            System.out.print(fonts[i].getFontName() + &quot; : &quot;);&#10;            System.out.println(fonts[i].getFamily());&#10;        }&#10;    }&#10;&#10;}&#10;" description="Creating a class template that uses graphic library in order to create ascii text" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::simpleSingelton" value="/*&#10; * When a few objects have the same values. &#10;   Instead of creating them a few times, and *each one of them have his object reference to the heap* (Memory leak!  out of memory exception),&#10;   we can make 1 object with the &quot;duplicated&quot; values and each semi-object will get the same heap-adress to him.&#10;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  &#10;  * ------------&#10;    | 4 steps: |&#10;    ------------&#10;         1. Make the &quot;main&quot; object in the class. this object will be *private static*&#10;            Others can reach to him but only from the class object (--&gt;From the getter [whom set to public])&#10;         2. Set the Constructor to private so no one could make another instance of the object&#10;         3. Generate *ONLY* getter - In order to reach to the object&#10;         4. Use multi-lock pattern when working with thread's:&#10;            When a program contains multi thread's and we want to have only 1 instance, we would have to use &quot;multi lock pattern&quot; in getInstance() method.&#10;            Multi lock is, a smart way to prevent from multi-thread program accidentally make more then one instance on the one hand,&#10;            and on the other hand - keep the program's performance as good as posible.&#10;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  &#10;  * Multi-lock: First condition: We want to reduce performance problems as posible,&#10;                                 So in order to do that - we would like to enter 'Synchronized' block only when instance is null&#10;                                 (-&gt; Instance have not been instanciated yet) and not each time getInstance() is invoked, otherwise - just return the instance.&#10;    Sychronized block: Using this block allows only to 1 thread continue each time. When 1 is already inside, other threads will wait. &#10;    Second condition:  When program have more then 1 thread, There could be a situation where 2 (or more) threads would enter the getInstance method at the same time and instance didn't instanciated yet.&#10;                       In this case, we would use the 'Syncronized' block in order to let only 1 thread continue and instanciate the instance.&#10;                       The problem is, when the first thread will finish and exit the block and since both threads already passed the null condition, &#10;                       the second thread will get in and instanciate another instance. &#10;                       To prevent that - We will make another condition after the 'Synchronized' block  in order to check if instance have been instanciated while second thread waited.&#10;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------      &#10;  * ------------&#10;    |  Notes:  |&#10;    ------------&#10;         1. You can make as much as free methods u want.&#10;         2. You can change the object values with the class setters (If you choose to make some.)&#10;            Changing it will change for all semi-object of course(because they have the same object reference adress in the heap)&#10;         3. Also, read here: https://www.ibm.com/developerworks/java/library/j-dcl/index.html&#10;&#10; */&#10;&#10;public class Singelton {&#10;&#10;    private static ClassName instance;&#10;&#10;    private ClassName(param1, param2, param3) {&#10;&#10;    }&#10;&#10;    public static 'ClassName' getInstance() {&#10;        if (instance == null) {&#10;            synchronized (ClassName.class) {&#10;                if (instance == null) {&#10;                    instance = new instance();&#10;                }&#10;            }&#10;        }&#10;        return instance;&#10;    }&#10;&#10;}&#10;" description="Simple singelton template" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::enumSingelton" value="public enum explainSingelton {&#10;// The name of the singelton enum class should the same as the name of the class you want to make singelton instance from (just include 'My' in the start of the name)&#10;&#10;    INSTANCE;&#10;// Creating 1 instance(live object) called 'INSTANCE'&#10;// This could also contain parameters. Ex: Company(&quot;Name&quot;); -&gt; Every param that we would like the INSTANCE to have should be instelaized in this class private ctr OR in the targetClass CTR&#10;&#10;    private TargetClassName targetClassName;&#10;// Creating an object called &quot;targetClassName&quot; which refers to TargetClassName class&#10;&#10;    public TargetClassName getInstance() {&#10;        return targetClassName;&#10;    }&#10;&#10;    private private explainSingelton() { // Private ctr&#10;        this.targetClassName = Adress // Adress should be link to the TargetClassName.Ctr which there we define all properties we want the single instance will have(like name)&#10;    }&#10;&#10;}&#10;&#10;class anyClass { // Example of other classes in the project&#10;&#10;    private void b() { // We should call the instance only from a functions(Best practice!)&#10;        explainSingelton.INSTANCE.getInstance(); // Example of how to invoke the singelton instance of TargetClassName&#10;    }&#10;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::beanController" value="&#10;@RestController&#10;@RequestMapping(&quot;X&quot;)&#10;@RequiredArgsConstructor&#10;public class CatController {&#10;&#10;    /* HttpStatus per HttpRequest:&#10;     * POST - ''OK'(200), 'Accepted'(202), 'Created'(201)&#10;     * PUT - 'OK'(200), 'Accepted'(202), 'No Content'(204)&#10;     * GET - 'OK'(200)&#10;     * DELETE - 'OK'(200), 'Accepted'(202), 'No Content'(204)&#10;     */&#10;&#10;    private final Service service;&#10;    private final Repo repo;&#10;&#10;    @PostMapping(&quot;add&quot;) // http://localhost:8080/X/add&#10;    @ResponseStatus(value = HttpStatus.CREATED)&#10;    public void add(@RequestBody Bean bean) {&#10;        service.add(bean);&#10;    }&#10;&#10;    @PutMapping(&quot;update&quot;) // http://localhost:8080/X/update&#10;    @ResponseStatus(value = HttpStatus.NO_CONTENT)&#10;    public void updateBean(@RequestBody Bean bean) throws BeanException {&#10;        service.update(bean);&#10;    }&#10;&#10;    @GetMapping(&quot;getSingle&quot;) // http://localhost:8080/X/getSingle&#10;    @ResponseStatus(value = HttpStatus.OK)&#10;    public ResponseEntity&lt;List&lt;Cat&gt;&gt; getSingle() {&#10;        return new ResponseEntity&lt;&gt;(service.getSingle(), HttpStatus.OK);&#10;    }&#10;&#10;    @GetMapping(&quot;getAll&quot;) // http://localhost:8080/X/getAll&#10;    @ResponseStatus(value = HttpStatus.OK)&#10;    public ResponseEntity&lt;List&lt;Cat&gt;&gt; getAllBean() {&#10;        return new ResponseEntity&lt;&gt;(service.getAll(), HttpStatus.OK);&#10;    }&#10;&#10;    @DeleteMapping(&quot;deleteById/{id}&quot;) // http://localhost:8080/X/deleteById/id&#10;    @ResponseStatus(value = HttpStatus.NO_CONTENT)&#10;    public void deleteBeanById(@PathVariable int id) throws BeanException {&#10;        service.delete(repo.getById(id));&#10;    }&#10;&#10;    @GetMapping(&quot;getAll/name/weight&quot;) // http://localhost:8080/X/getAllByNameAndWeight?name=Litzi&amp;weight=3.1&#10;    public ResponseEntity&lt;List&lt;Cat&gt;&gt; getAllByNameAndWeight(@RequestParam String name, @RequestParam float weight) throws BeanException {&#10;        return new ResponseEntity&lt;&gt;(service.getAllByNameAndWeight(name, weight), HttpStatus.OK);&#10;    }&#10;&#10;}" description="Creating a bean controller template" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::appProperties" value="spring.datasource.url=jdbc:mysql://localhost:3306/Schema_Name?serverTimezone=UTC&amp;createDatabaseIfNotExist=true&#10;spring.datasource.username=root&#10;spring.datasource.password=smdesktop1234&#10;spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver&#10;&#10;spring.jpa.hibernate.ddl-auto=create-drop&#10;spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect&#10;spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true&#10;// spring.datasource.hikari.maximumPoolSize=5" description="Basic template of application properties for new Spring project" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="sm::sql::connectionPool" value="public class ConnectionPool {&#10;    &#10;    private static final int NUM_OF_CONS = 10;&#10;    private static ConnectionPool instance = null;&#10;    private final Stack&lt;Connection&gt; connections = new Stack&lt;&gt;();&#10;&#10;    private ConnectionPool() throws SQLException {&#10;        openAllConnections();&#10;    }&#10;&#10;    public static ConnectionPool getInstance() {&#10;        if (instance == null) {&#10;            synchronized (ConnectionPool.class) {&#10;                if (instance == null) {&#10;                    try {&#10;                        instance = new ConnectionPool();&#10;                    } catch (SQLException e) {&#10;                        System.err.println(&quot;[getInstance] &quot; +e.getMessage());&#10;                    }&#10;                }&#10;&#10;            }&#10;        }&#10;        return instance;&#10;    }&#10;&#10;    public Connection getConnection() throws InterruptedException {&#10;        synchronized (connections) {&#10;            if(connections.isEmpty()) {&#10;                connections.wait();&#10;            }&#10;            return connections.pop();&#10;        }&#10;    }&#10;&#10;    public void returnConnection(Connection connection) {&#10;        synchronized (connections) {&#10;            connections.push(connection);&#10;            connections.notify();&#10;        }&#10;    }&#10;&#10;    public void openAllConnections() throws SQLException {&#10;        for (int i = 0; i &lt; NUM_OF_CONS; i++) {&#10;            connections.push(DatabaseManager.connect());&#10;        }&#10;    }&#10;&#10;    public void closeAllConnections() throws InterruptedException {&#10;        synchronized (connections) {&#10;            while(connections.size() &lt; NUM_OF_CONS) {&#10;                connections.wait();&#10;            }&#10;            connections.removeAllElements();&#10;        }&#10;    }&#10;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::sql::DBUtils" value="&#10;import com.jb.db.ConnectionPool;&#10;import com.mysql.cj.protocol.Resultset;&#10;import java.sql.Connection;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.SQLException;&#10;import java.util.Date;&#10;import java.util.Map;&#10;&#10;public class DBUtils {&#10;&#10;    private static Connection connection;&#10;&#10;    public static void runQuery(String psQuery, Map&lt;Integer, Object&gt; params) {&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(psQuery);&#10;            params.forEach((key, value) -&gt; {&#10;                try {&#10;                    if (value instanceof Integer) {&#10;                        ps.setInt(key, (int) value);&#10;                    } else if (value instanceof Double) {&#10;                        ps.setDouble(key, (Double) value);&#10;                    } else if (value instanceof Float) {&#10;                        ps.setFloat(key, (Float) value);&#10;                    } else if (value instanceof Long) {&#10;                        ps.setLong(key, (Long) value);&#10;                    } else if (value instanceof Date) {&#10;                        ps.setDate(key, (java.sql.Date) value);&#10;                    } else if (value instanceof Boolean) {&#10;                        ps.setBoolean(key, (Boolean) value);&#10;                    } else if (value instanceof Enum) {&#10;                        ps.setObject(key, value.toString());&#10;                    } else {&#10;                        ps.setString(key, (String) value);&#10;                    }&#10;                } catch (Exception e) {&#10;                    System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;                }&#10;            });&#10;            ps.execute();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;    }&#10;&#10;    public static ResultSet runQueryGetResultSet(String psQuery, Map&lt;Integer, Object&gt; params) {&#10;        Resultset rs = null;&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(psQuery);&#10;            params.forEach((key, value) -&gt; {&#10;                try {&#10;                    if (value instanceof Integer) {&#10;                        ps.setInt(key, (int) value);&#10;                    } else if (value instanceof Double) {&#10;                        ps.setDouble(key, (Double) value);&#10;                    } else if (value instanceof Float) {&#10;                        ps.setFloat(key, (Float) value);&#10;                    } else if (value instanceof Long) {&#10;                        ps.setLong(key, (Long) value);&#10;                    } else if (value instanceof Date) {&#10;                        ps.setDate(key, (java.sql.Date) value);&#10;                    } else if (value instanceof Boolean) {&#10;                        ps.setBoolean(key, (Boolean) value);&#10;                    } else {&#10;                        ps.setString(key, (String) value);&#10;                    }&#10;                } catch (Exception e) {&#10;                    System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;                }&#10;            });&#10;            rs = (Resultset) ps.executeQuery();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;        return (ResultSet) rs;&#10;    }&#10;&#10;    public static boolean runQueryGetBool(String psQuery, Map&lt;Integer, Object&gt; params) {&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(psQuery);&#10;            params.forEach((key, value) -&gt; {&#10;                try {&#10;                    if (value instanceof Integer) {&#10;                        ps.setInt(key, (int) value);&#10;                    } else if (value instanceof Double) {&#10;                        ps.setDouble(key, (Double) value);&#10;                    } else if (value instanceof Float) {&#10;                        ps.setFloat(key, (Float) value);&#10;                    } else if (value instanceof Long) {&#10;                        ps.setLong(key, (Long) value);&#10;                    } else if (value instanceof Date) {&#10;                        ps.setDate(key, (java.sql.Date) value);&#10;                    } else if (value instanceof Boolean) {&#10;                        ps.setBoolean(key, (Boolean) value);&#10;                    } else {&#10;                        ps.setString(key, (String) value);&#10;                    }&#10;                } catch (Exception e) {&#10;                    System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;                }&#10;            });&#10;            ps.execute();&#10;            ResultSet rs = ps.executeQuery();&#10;            if (rs.next()) {&#10;                return true;&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public static void runQuery(String query) {&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(query);&#10;            ps.execute();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;[runQuery] &quot; +e.getMessage());&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;    }&#10;&#10;    public static void delete(String tag, String query, int id) throws SQLException, InterruptedException {&#10;        try {&#10;            connection = ConnectionPool.getInstance().getConnection();&#10;            PreparedStatement ps = connection.prepareStatement(query);&#10;            ps.setInt(1, id);&#10;            ps.execute();&#10;        } catch (SQLException | InterruptedException e) {&#10;            System.err.println(&quot;[delete&quot; + tag + &quot;] &quot; + e.getMessage());&#10;            throw e;&#10;        } finally {&#10;            ConnectionPool.getInstance().returnConnection(connection);&#10;        }&#10;    }&#10;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::binarySerialization" value="class SerializationUtils {&#10;&#10;/* &#10;* Serialization basics by JetBrains Academy - https://hyperskill.org/learn/step/8147 *&#10;&#10;The lifetime of all objects within a program is limited by the runtime.&#10;When we stop and then reopen the program, the information about previously created objects is lost.&#10;Fortunately, a program can save objects to some permanent storage like a hard drive and read them back the next time the program starts.&#10;To make a class serializable, it must implement the 'Serializable' interface.&#10;&#10;private static final long serialVersionUID = 7L; - &#10;The 'serialVersionUID' field is used to verify that the sender and the receiver of a serialized object are compatible and have loaded the classes for that object.&#10;If the version number of the sender and receiver classes don't match,&#10;then the runtime error InvalidClassException occurs.&#10;The matching of this value happens “under the hood” during serialization and deserialization.&#10;An error occurs only in cases of mismatch. &#10;&#10;Here is a small description of the given code:&#10;'FileOutputStream' and F'ileInputStream' are used for working with a file;&#10;'BufferedInputStream' and 'BufferedOutputStream' are optional but useful for speeding up the I/O operations;&#10;'ObjectOutputStream' and 'ObjectInputStream' perform serialization and deserialization of objects and also invoke wrapped streams to work with the file;&#10;both methods also close the streams to avoid resource leaks.&#10;*/&#10;&#10;    public static void serialize(Object obj, String fileName) throws IOException {&#10;    // Serialize the given object to the file&#10;        FileOutputStream fos = new FileOutputStream(fileName);&#10;        BufferedOutputStream bos = new BufferedOutputStream(fos);&#10;        ObjectOutputStream oos = new ObjectOutputStream(bos);&#10;        oos.writeObject(obj);&#10;        oos.close();&#10;    }&#10;&#10;    public static Object deserialize(String fileName) throws IOException, ClassNotFoundException {&#10;    // Deserialize to an object from the file&#10;        FileInputStream fis = new FileInputStream(fileName);&#10;        BufferedInputStream bis = new BufferedInputStream(fis);&#10;        ObjectInputStream ois = new ObjectInputStream(bis);&#10;        Object obj = ois.readObject();&#10;        ois.close();&#10;        return obj;&#10;    }&#10;}" description="Template of binary serialization and desirialization functions" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::txtFileWritter" value="/*When to use each serialization:&#10;In general the important question is which client will receive the serialized objects - browsers/JavaScript engines like (node-js), Java client, unknown/multiple clients.&#10;&#10;JSON - JSON syntax is basically JavaScript and therefore any component with a JS engine will handle its parsing very well - &#10;even complicated data-structures will be converted to &quot;living&quot; objects efficiently. &#10;JSON parsers exist for practically any language and it is easy to use even when not using a JS engine, &#10;(Take Google Gson for example that is able to convert JSON into corresponding objects with ease) &#10;which makes is a good candidate for cross-language communication - for example in a messaging architecture.&#10;&#10;XML - Shares many of JSON's benefits -cross-language, lightweight, etc.&#10;Adobe Flex for example handles XML very well, even better than JSON.&#10;It's definitely an appropriate substitute for JSON. &#10;I personally prefer JSON for its JS like syntax, but XML is also good.&#10;&#10;Java Serialization - Should be considered only for Java-to-Java communication.&#10;An important note is that the class definitions should be on the sending and the receiving ends and often you wouldn't gain much by passing the entire object.&#10;I wouldn't rule out RMI as a communication protocol, it does simplify development.&#10;However the resulting application components will be hard coupled which will make it very difficult to replace.&#10;&#10;One more notes - Serialization in general has its overhead.&#10;However, when the communication is performed over a network -&#10;the bottleneck is often the network rather than the serialization/deserialization itself.&#10;&#10;--------------------------------------------------------------------------------------&#10;&#10;While serialization over the network both XML and JSON would work.&#10;It depends on the consumer of this information.&#10;&#10;If the consumer is a browser using Ajax to request some information and render something on the screen,&#10;generally JSON is the best bet as its already in Javascript object format and there is no overhead of converting to Javascript compatible objects.&#10;In fact many Ajax libs (e.g. jQuery) have good support for JSON.&#10;&#10;If you consumer is another application which may or may not be in java, &#10;then XML is the prefer serialization mechanism. Web services use XML very heavily.&#10;&#10;If your consumer is another Java program then definitely java serialization is preferred option (e.g. RMI). &#10;*/&#10;&#10;import java.io.BufferedReader;&#10;import java.io.BufferedWriter;&#10;import java.io.File;&#10;import java.io.FileReader;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;&#10;public class writtingAndReadingFromFile {&#10;&#10;&#9;public static final String PATH = &quot;&quot;;&#10;&#10;&#9;public static void write(String path, String text, boolean append) throws IOException { &#10;&#9;&#9;// false - override | true - newLine&#10;&#9;&#9;File file = new File(path);&#10;&#9;&#9;FileWriter fileWriter = new FileWriter(file, append);&#10;&#9;&#9;BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);&#10;        if(!file.exists()) {&#10;            file.createNewFile();&#10;        }&#10;    &#9;&#9;bufferedWriter.write(text);&#10;    &#9;&#9;bufferedWriter.newLine();&#10;    &#9;&#9;bufferedWriter.close();&#9;&#9;&#10;&#9;}&#10;&#10;&#9;public static void read(String path) throws IOException {&#10;&#9;&#9;File file = new File(path);&#10;&#9;&#9;FileReader fileReader = new FileReader(file);&#10;&#9;&#9;BufferedReader bufferedReader = new BufferedReader(fileReader);&#10;&#9;&#9;String txt;&#10;&#9;&#9;while ((txt = bufferedReader.readLine()) != null) {&#10;&#9;&#9;&#9;System.out.println(bufferedReader.readLine());&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;}&#10;" description="Template of txt serialization and desirialization functions" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::passwordHashWithMD5" value="  public static String EncrpytPassword(String password) {&#10;&#9;&#9;String passwordToHash = &quot;password&quot;;&#10;&#9;&#9;String generatedPassword = null;&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;// Create MessageDigest instance for MD5&#10;&#9;&#9;&#9;MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);&#10;&#9;&#9;&#9;// Add password bytes to digest&#10;&#9;&#9;&#9;md.update(password.getBytes());&#10;&#9;&#9;&#9;// Get the hash's bytes&#10;&#9;&#9;&#9;byte[] bytes = md.digest();&#10;&#9;&#9;&#9;// This bytes[] has bytes in decimal format;&#10;&#9;&#9;&#9;// Convert it to hexadecimal format&#10;&#9;&#9;&#9;StringBuilder sb = new StringBuilder();&#10;&#9;&#9;&#9;for (int i = 0; i &lt; bytes.length; i++) {&#10;&#9;&#9;&#9;&#9;sb.append(Integer.toString((bytes[i] &amp; 0xff) + 0x100, 16).substring(1));&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;// Get complete hashed password in hex format&#10;&#9;&#9;&#9;generatedPassword = sb.toString();&#10;&#9;&#9;} catch (NoSuchAlgorithmException e) {&#10;&#9;&#9;&#9;e.printStackTrace();&#10;&#9;&#9;}&#10;    //System.out.println(generatedPassword);&#10;&#9;&#9;return generatedPassword;&#10;&#9;}" description="Password encryption" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::dateUtils" value="public class DateUtils {&#10;&#10;    private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;dd/MM/yyyy&quot;);&#10;&#10;    /**&#10;     * Formats the params into a date format.&#10;     */&#10;    public static Date getDate(int day, int month, int year) {&#10;        try {&#10;            return simpleDateFormat.parse(String.format(&quot;%2d/%2d/%4d&quot;, day, month, year));&#10;        } catch (ParseException e) {&#10;            System.err.println(&quot;[getDate] &quot; + e.getMessage());&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Returns the date param as a formatted date pattern 'simpleDateFormat'.&#10;     */&#10;    public static String dateFormatter(Date date) {&#10;        return simpleDateFormat.format(date);&#10;    }&#10;&#10;    /**&#10;     * Converts the data type from java.Date to sql.&#10;     */&#10;    public static java.sql.Date convertDataType(Date date) {&#10;        return new java.sql.Date(date.getTime());&#10;    }&#10;&#10;    public static LocalDate convertDataToLocalDate(Date date) { // TODO: Consider removing&#10;        return Instant.ofEpochMilli(date.getTime()).atZone(ZoneId.systemDefault()).toLocalDate();&#10;    }&#10;&#10;    public static Date convertLocalDateToDate(LocalDate date) { // TODO: Consider removing&#10;        return Date.from(Instant.from(date));&#10;    }&#10;&#10;    public static LocalDate getDateOfToday() {&#10;        return LocalDate.now();&#10;    }&#10;&#10;}&#10;/* LocalDate only:&#10;package com.jb.utils;&#10;&#10;import java.time.LocalDate;&#10;&#10;public class DateUtils {&#10;&#10;    public static LocalDate getDate(int day, int month, int year) {&#10;       return LocalDate.of(year, month, year);&#10;    }&#10;&#10;    public static java.sql.Date convertLocalDateToSQL(LocalDate date) {&#10;        return java.sql.Date.valueOf(date);&#10;    }&#10;&#10;    public static String beautifyDate(LocalDate date) {&#10;        return String.format(&quot;%02d/%02d/%04d&quot;, date.getDayOfMonth(), date.getMonthValue(), date.getYear());&#10;    }&#10;&#10;    public static LocalDate convertSQLDateToLocalDate(java.sql.Date date) {&#10;        return LocalDate.parse((CharSequence) date);&#10;    }&#10;}&#10;*/&#10;" description="Template of date convertors" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::getLocalIpAdress" value="&#10;import java.net.InetAddress;&#10;&#10;class IPAddressExample {&#10;    public static void main(String args[]) throws Exception {&#10;        InetAddress inetAddress = InetAddress.getLocalHost();&#10;        System.out.println(&quot;IP Address:- &quot; + inetAddress.getHostAddress());&#10;        System.out.println(&quot;Host Name:- &quot; + inetAddress.getHostName());&#10;    }&#10;}&#10;&#10;// +-----------------------------------------------------------------------------------------------------------------------------------------------------------------+&#10;&#10;// Java program to find IP address of your computer&#10;// java.net.InetAddress class provides method to get&#10;// IP of any host name&#10;import java.net.*;&#10;        import java.io.*;&#10;        import java.util.*;&#10;        import java.net.InetAddress;&#10;&#10;public class JavaProgram&#10;{&#10;    public static void main(String args[]) throws Exception&#10;    {&#10;        // Returns the instance of InetAddress containing&#10;        // local host name and address&#10;        InetAddress localhost = InetAddress.getLocalHost();&#10;        System.out.println(&quot;System IP Address : &quot; +&#10;                (localhost.getHostAddress()).trim());&#10;&#10;        // Find public IP address&#10;        String systemipaddress = &quot;&quot;;&#10;        try&#10;        {&#10;            URL url_name = new URL(&quot;http://bot.whatismyipaddress.com&quot;);&#10;&#10;            BufferedReader sc =&#10;                    new BufferedReader(new InputStreamReader(url_name.openStream()));&#10;&#10;            // reads system IPAddress&#10;            systemipaddress = sc.readLine().trim();&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            systemipaddress = &quot;Cannot Execute Properly&quot;;&#10;        }&#10;        System.out.println(&quot;Public IP Address: &quot; + systemipaddress +&quot;\n&quot;);&#10;    }&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::binaryBaseConvertor" value="&#9;public static void makeBinaryArray(int num) {&#10;&#9;    if(num&gt;=0 &amp;&amp; num&lt;=255) {&#10;&#9;    &#9;int[] byteArray = new int[8];&#10;&#9;     &#9;int byteIdx = byteArray.length - 1;&#10;&#9;    &#9;int counter = 0;&#10;&#9;    &#9;while (byteIdx &gt;= 0) {&#10;&#9;    &#9;&#9;int dropDown = (int) Math.pow(2, byteIdx);&#10;&#9;&#9;&#9;    if (num &gt;= 0 &amp;&amp; num &gt;= dropDown) {&#10;&#9;&#9;&#9;    &#9;byteArray[counter] = 1;&#10;&#9;&#9;&#9;    &#9;num -= dropDown;&#10;&#9;&#9;&#9;    }&#10;&#9;&#9;&#9;    counter++;&#10;&#9;&#9;&#9;    byteIdx--;&#10;&#9;&#9;    }&#10;&#9;&#9;    for (int i = 0; i &lt; byteArray.length; i++) {&#10;&#9;&#9;    &#9;System.out.print(byteArray[i] + &quot; &quot;);&#10;&#9;&#9;     }&#10;    &#9;} else {&#10;&#9;    &#9; System.out.println(&quot;- Error - \nOops, somthing went wrong! \nPlease make sure that your number is between 0-255 and try again&quot;);&#10;&#9; }&#10;&#9;}&#10;&#10;&#10;-------------------------------------------------------------------------------------&#10;&#10;&#9;public static int[] convertNumTo8BitsArrays(int num) {&#10;&#9;&#9;int[] bits = new int[8];&#10;&#9;&#9;for (int i = 0; i &lt; bits.length; i++) {&#10;&#9;&#9;&#9;int down = (int) Math.pow(2, (bits.length - 1) - i);&#10;&#9;&#9;&#9;if (num &gt;= 0 &amp;&amp; num &gt;= down) {&#10;&#9;&#9;&#9;&#9;num -= down;&#10;&#9;&#9;&#9;&#9;bits[i] = 1;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;return bits;&#10;&#9;}&#10;&#10;&#9;public static int convert8BitsArrayToInt(int[] bits) {&#10;&#9;&#9;int sum = 0;&#10;&#9;&#9;for (int i = bits.length - 1; i &gt;= 0; i--) {&#10;&#9;&#9;&#9;if (bits[i] == 1) {&#10;&#9;&#9;&#9;&#9;int add = (int) (Math.pow(2, bits.length-1-i));&#10;&#9;&#9;&#9;&#9;sum += add;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return sum;&#10;&#9;}&#10;&#10;&#9;public static void print(int[] arr) {&#10;&#9;&#9;for (int i = 0; i &lt; arr.length; i++) {&#10;&#9;&#9;&#9;System.out.print(arr[i] + &quot; &quot;);&#10;&#9;&#9;}&#10;&#9;&#9;System.out.println();&#10;&#9;}&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::task" value="import lombok.RequiredArgsConstructor;&#10;import org.springframework.scheduling.annotation.Scheduled;&#10;import org.springframework.stereotype.Component;&#10;&#10;@Component&#10;@RequiredArgsConstructor&#10;public class DailyInterviewProcessor {&#10;&#10;    private final BeanRepo beanRepo;&#10;    private static final int DAY = 1000 * 60 * 60 * 24;&#10;    private static final int DEVELOPER_TEST = 1000 * 60;&#10;&#10;    @Scheduled(fixedRate = DEVELOPER_TEST)&#10;    public void run() {&#10;        // Insert task here&#10;    }&#10;    &#10;}&#10;" description="Creates a task template" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::passwordEncoder" value="    package x.security;&#10;&#10;    import org.springframework.context.annotation.Configuration;&#10;    &#10;    @Configuration&#10;    public class PasswordConfig() {&#10;&#10;        @Bean&#10;        public PasswordEncoder encoder() {&#10;            return new BCryptPasswordEncoder(10); // Empty constractur works too.&#10;        }&#10;    &#10;    }&#10;    &#10;    /*&#10;    &#10;    public void setPassword(String password) { // Setter injection in the bean itself&#10;        this.password = encoder().encode(password);&#10;    }&#10;    &#10;     */&#10;" description="Basic template of spring password encoding with BCRYPT" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::applicationSecurityConfig" value="import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;&#10;&#10;@Configuration&#10;@EnableWebSecurity&#10;public class ApplicationSecurityConfig extends WebSecurityConfigurerAdapter {&#10;&#10;    @Override&#10;    protected void configure(HttpSecurity http) throws Exception {&#10;        http&#10;                .authorizeRequests()&#10;                .antMatchers(&quot;/&quot;, &quot;index&quot;, &quot;/css/*&quot;, &quot;/js/*&quot;) // The file endings that wont need to login with user and password&#10;                .permitAll()&#10;                .anyRequest()&#10;                .authenticated()&#10;                .and()&#10;                .httpBasic();&#10;    }&#10;&#10;}" description="Basic template for spring configuration file for web security" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::advice" value="import com.example.PreTestHomeWork2.exceptions.CatsException;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.web.bind.annotation.ControllerAdvice;&#10;import org.springframework.web.bind.annotation.ExceptionHandler;&#10;import org.springframework.web.bind.annotation.ResponseStatus;&#10;import org.springframework.web.bind.annotation.RestController;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@RestController&#10;@ControllerAdvice&#10;public class ErrorDetails {&#10;&#10;    private String key;&#10;    private String value;&#10;&#10;    @ExceptionHandler(value = {CatsException.class})&#10;    @ResponseStatus(code = HttpStatus.BAD_REQUEST)&#10;    public ErrorDetails handleException(Exception e) {&#10;            return new ErrorDetails(&quot;[Error]&quot;, e.getMessage());&#10;        }&#10;&#10;}" description="Creates a basic template for error handling via spring" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::setSwaggerConfiguration" value="/* &#10; *Maven Dependencies:&#10; &lt;dependenices&gt;&#10;&#9;&#9;&#9;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;&#10;&#9;&#9;&#9;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;&#10;&#9;&#9;&#9;    &lt;version&gt;2.9.2&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&#9;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;&#10;&#9;&#9;&#9;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;&#10;&#9;&#9;&#9;    &lt;version&gt;2.9.2&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&lt;/dependenices&gt;&#10;&#10; *Enjoy:&#10;  http://localhost:8080/swagger-ui.html&#10;*/&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import springfox.documentation.builders.PathSelectors;&#10;import springfox.documentation.builders.RequestHandlerSelectors;&#10;import springfox.documentation.spi.DocumentationType;&#10;import springfox.documentation.spring.web.plugins.Docket;&#10;import springfox.documentation.swagger2.annotations.EnableSwagger2;&#10;&#10;@Configuration&#10;@EnableSwagger2&#10;public class SwaggerConfiguration {&#10;&#10;    @Bean&#10;    public Docket api() {&#10;        return new Docket(DocumentationType.SWAGGER_2)&#10;                .select()&#10;                .apis(RequestHandlerSelectors.any())&#10;                .paths(PathSelectors.any())&#10;                .build();&#10;    }&#10;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::beanControllerTesting" value="import lombok.RequiredArgsConstructor;&#10;import org.springframework.boot.CommandLineRunner;&#10;import org.springframework.core.annotation.Order;&#10;import org.springframework.http.HttpEntity;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;@Order(2)&#10;@RequiredArgsConstructor&#10;@Component&#10;public class BeanControllerTesting implements CommandLineRunner {&#10;&#10;    private final RestTemplate restTemplate;&#10;    private final Service service;&#10;    private static String URL = &quot;http://localhost:8080/X&quot;;&#10;&#10;    @Override&#10;    public void run(String... args) throws Exception {&#10;&#10;        System.out.println(&quot;---------------------------------------------------------------------------------------------------------------------&quot;);&#10;         /* Note:&#10;             1) In order to have 'true' values,&#10;                Compare the HttpStatus.Enum for each method test here with the Enum selected in the controller.&#10;             2) Compare method names with the string added to the url in each http method here.&#10;          */&#10;&#10;        // POST&#10;        Bean toAdd = new Bean();&#10;        ResponseEntity&lt;String&gt; postResult = restTemplate.postForEntity(URL + &quot;/add&quot;, toAdd, String.class);&#10;        System.out.println(postResult.getStatusCodeValue() == HttpStatus.CREATED.value());&#10;        System.out.println(&quot;POST response: &quot; + postResult);&#10;&#10;        // PUT&#10;        service.add(toAdd);&#10;        toAdd.setName(&quot;Shay&quot;);&#10;        HttpEntity&lt;?&gt; updateRequest = new HttpEntity&lt;&gt;(toAdd);&#10;        ResponseEntity&lt;String&gt; putResult = restTemplate.exchange(URL + &quot;/update&quot;, HttpMethod.PUT, updateRequest, String.class);&#10;        System.out.println(&quot;PUT response: &quot; + putResult);&#10;        System.out.println(putResult.getStatusCodeValue() == HttpStatus.NO_CONTENT.value());&#10;&#10;        // GET&#10;        System.out.println(&quot;GET response: &quot; + restTemplate.getForObject(URL + &quot;/getAll&quot;, String.class));&#10;&#10;        // DELETE&#10;        HttpEntity&lt;?&gt; deleteRequest = new HttpEntity&lt;&gt;(toAdd);&#10;        ResponseEntity&lt;String&gt; deleteResult = restTemplate.exchange(URL + &quot;/deleteById/{id}&quot;, HttpMethod.DELETE, deleteRequest, String.class, 1);&#10;        System.out.println(&quot;DELETE response: &quot; + deleteResult);&#10;        System.out.println(deleteResult.getStatusCodeValue() == 204);&#10;&#10;    }" description="A coded version of HTTP client using RestTemplate" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::TokenManager" value="import org.springframework.stereotype.Component;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.UUID;&#10;&#10;@Component&#10;public class TokenManager {&#10;&#10;    private static Map&lt;Integer, UUID&gt; tokens = new HashMap&lt;&gt;();&#10;    private static int counter = 0;&#10;&#10;    public static UUID generateToken() {&#10;        UUID token = UUID.randomUUID();&#10;        while (tokens.containsValue(token)) {&#10;            token = UUID.randomUUID();&#10;        }&#10;        tokens.put(counter++, token);&#10;        return token;&#10;    }&#10;&#10;}&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::stamp" value="/* @File creates by Shay Marko&#10;     * File: filePath().fileName()&#10;     * Timestamp: date(&quot;Y-MM-d, E, H:m&quot;)&#10;     * Description: &#10;*/" description="Developer stamp" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::spring::simpleEntity" value="import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import javax.persistence.*;&#10;&#10;@Entity&#10;@Data&#10;@NoArgsConstructor&#10;public class Bean {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY) // Each obj gets his own key&#10;    private int Id;&#10;&#10;}&#10;" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="sm::general::simpleException" value="public class BeanException extends Exception {&#10;&#10;    public BeanException(String msg) {&#10;        super(msg);&#10;    }&#10;&#10;}" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
</templateSet>
